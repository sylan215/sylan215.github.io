<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[next 主题下点击后出现红心效果]]></title>
    <url>%2Fhexo-next-hongxin.html</url>
    <content type="text"><![CDATA[在 hexo\themes\next\source\js\src\ 目录下新增文件 love.js，文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546!function(e, t, a) &#123; function n() &#123; c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = "left:" + d[e].x + "px;top:" + d[e].y + "px;opacity:" + d[e].alpha + ";transform:scale(" + d[e].scale + "," + d[e].scale + ") rotate(45deg);background:" + d[e].color + ";z-index:99999"); requestAnimationFrame(r) &#125; function o() &#123; var t = "function" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function(e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement("div"); a.className = "heart", d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement("style"); a.type = "text/css"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName("head")[0].appendChild(a) &#125; function s() &#123; return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")" &#125; var d = []; e.requestAnimationFrame = function() &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n()&#125;(window, document); 然后在文件 hexo\themes\next\layout\_layout.swing 底部的 &lt;/body&gt; 标签上一行增加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 好了，执行命令 hexo s --debug 看看效果吧。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>红心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个版本的 Python 在使用中的灵活切换]]></title>
    <url>%2Fpython-config-build.html</url>
    <content type="text"><![CDATA[今天我们来说说在 windows 系统上如果有多版本的 python 并存时，如何优雅的进行灵活切换。虽然 Python3 已经出来很久了，虽然 Python2 即将成为历史了，但是因为历史原因，依然有很多公司的老项目继续在使用着 Python2 版本(切换成本太高)，所以大多数开发者机器上 Python2 和 Python3 都是并存的，本文主要说明这种情况下如何便捷的在 Python2 和 Python3 之间进行切换。 先说明下，本次我们不介绍 virtualenv，也不介绍 pipenv，因为这两个都是为了大型的 Python 工程做准备的，之后会单独文字进行说明。 本次是不借助外部工具，来实现快捷切换。其实也可以说是利用系统环境变量的逻辑来实现目的。 本次环境以 Windows 为例： 系统： Windows 7 x64Python 版本：Python3.4 和 Python 2.7 安装首先安装好 Python3.4 和 Python2.7，安装包可以在这个地方进行下载：点击跳转。 设置环境变量然后分别把对应版本的安装路径加入到系统环境变量中去： 新起一个 cmd 窗口验证下添加后的效果： 123C:\Users&gt;pathPATH=C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files\Git\cmd;C:\Python34;C:\Python27; 这时候我们直接在 cmd 输入 python，已经可以被识别了，但是识别的总是路径在环境变量中排前面的那个版本的 Python，比如目前从上图看 Python3.4 是排前面的，实际验证下看看： 12345C:\Users&gt;pythonPython 3.4.4 (v3.4.4:737efcadf5a6, Dec 20 2015, 20:20:57) [MSC v.1600 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 重命名主程序然后我们分别把两个版本的 Python 主程序 exe 改下名，3.4 版本的改名为 python34.exe，2.7 版本的改名为 python27.exe： 再分别运行 python34 和 python27 试试： 1234567891011C:\Users&gt;python34Python 3.4.4 (v3.4.4:737efcadf5a6, Dec 20 2015, 20:20:57) [MSC v.1600 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;C:\Users&gt;python27Python 2.7.14 (v2.7.14:84471935ed, Sep 16 2017, 20:19:30) [MSC v.1500 32 bit (Intel)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 从上图可以看出，我们已经可以实现分别运行指定版本的效果了，如果执行脚本的话直接 python34 test.py 或者 python27 test.py 就行了。 但是每次执行脚本都加前缀是不是很累，如果有一个版本是我们常用的话，也可以通过修改文件后缀关联程序来实现默认关联，再需要特殊版本的时候再加上前缀就行，不过保险起见，还是一直带着吧。 补充说明补充说明下，其实网上也有网友提供了其他两种方法： 使用 Python 自带的 py -2 和 py -3 命令；另一种和我上面说的类似，但是只重命名了其中一个版本的执行文件名； 如果机器只安装了两个版本的 Python，这几个方法确实是都可以解决的，但是因为我需要部分脚本支持 Windows XP (Python3.5 以后就不支持 XP 了)，所以安装了 Python2.7、Python3.4 和 Python3.6 共三个版本的 Python，这样的话就只能把全部主程序文件都重命名了，而且这样解决的问题更彻底，一劳永逸。 再补充说明下，如果要针对不同版本的 Python 调用 pip，命令后如下(请把 requests 换成自己需要的包名)： 123python27 -m pip install requestspython34 -m pip install requestspython36 -m pip install requests 这样安装的依赖库就是在各个版本之间相互独立的。 好了，赶紧动手试试吧。当然，如果您有更好的建议，欢迎留言讨论。]]></content>
      <categories>
        <category>environment</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>python多版本共存</tag>
        <tag>windows python多版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何删除 Launchpad 中的无用图标]]></title>
    <url>%2Frestore-launchpad.html</url>
    <content type="text"><![CDATA[最近在 Mac 上使用 Atom，发现 Atom 并不是安装上去的，下载后解压直接就是个 app 了，所以我手动给拖拽到 Launchpad 了。今天突然发现有个新版本，所以重新下载了一个，双击运行后，发现两个并不是同一个来源，所以就把老的源文件给删掉了，但是老版本对应的 Launchpad 图标还在，搞不懂。 所以又手动拖了一遍新版本 Atom 到 Launchpad，这下可好，竟然有两个 Atom 图标了，尝试使用长按后点叉叉的方式给删掉，却发现这俩图标上面竟然没有叉叉，郁闷了，人肉到网上搜了几个方案都不是特别实用，终于找到一个亲测可用的赶紧记录备案。 步骤： 在 Docker -&gt; 系统偏好设置 中打开终端 终端中输入：defaults write com.apple.dock ResetLaunchPad -bool true 后回车 终端中输入：killall Dock 后回车 重新打开 Docker 查看效果，一切都被还原，赞 注意：这种方式会还原自己自定义的一切设置，比如图标分类等，请按需取用]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>Launchpad</tag>
        <tag>恢复</tag>
        <tag>删除图标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心流]]></title>
    <url>%2Fheart-flow.html</url>
    <content type="text"><![CDATA[最近在看《驱动力》这本书，其中有提到「心流」这个词，只是从描述来说，有点太抽象，不过刚好最近感受了几次「心流」的感觉，所以记录一下。先说下概念，心流主要是指一种自动的、非刻意的、高度集中、全情投入并享受其中的的忘我精神状态。 我自己感受到的「心流」状态是最近在学习 python 编程，通过编写一些工作中需要用到的工具的过程。 这个过程中的带来的特殊感受有： 自己制定目标，自己规划目标，并自觉的持续达成；达成目标过程中的所有问题都有耐心并积极的寻求问题的解决办法；时间过得特别快，甚至愿意花费自己的休息时间来保证目标达成；持续的改进动力，且没有对回报的渴求，更加享受这个过程； 其中有三次典型的心流峰值，下面分别说明。 第一次是解决一个编码的问题。这是一个工具的需求，需求是使用字符串形式读取一个 PE 文件，然后暴力搜索其中的字符串。 同样的实现语句，在 Python2 中的输出是正确的，但是在 Python3 中的输出却不正确，检查发现和默认编码有关系，Python2 默认使用的 ascii，而 Python3 默认使用的是 utf-8，如果使用记事本打开的话，默认也是使用 ascii，所以和 Python2 的效果一样。 为了让实现效果一致，在 Python3 的实现中我显式设置 encoding 为 gbk 了： 1f = open(readFile, 'r', encoding='gbk') 结果就是这个语句报错了：1'gbk' codec can't decode byte 0x90 in position 2: illegal multibyte sequence 也就是这个错误导致我纠结了很久，花费了不少的时间，甚至有一段时间都搁置了，最终我把问题提交到了 stackoverflow，同时继续查资料，也就是提交问题后不久，就在 python 官方文档中找到了解决方案： 12345The errors parameter is the same as the parameter of the decode() method butsupports a few more possible handlers. As well as &apos;strict&apos;, &apos;ignore&apos;, and&apos;replace&apos; (which in this case inserts a question mark instead of the unencodable character), there is also &apos;xmlcharrefreplace&apos; (inserts an XML characterreference) and backslashreplace (inserts a \uNNNN escape sequence). 其实还是蛮讽刺的，因为基础没打牢，一个基本的函数实现却耗费了不少的时间，虽然解决问题后，那种兴奋的感觉还是蛮让人激动，不过最大的收获还是发现问题先看官方文档。 上述问题的详细描述可以 看 stackoverflow。 第二次是解决一个打包的问题。因为我的工具会分发给大家使用，但不是每个人的环境都安装了 Python3，或者即使安装了，相关的依赖库也不一定完备，所以我是使用 pyinstaller 进行了打包后再进行分发的，但是因为 pyinstaller 自身的 Bug，让我打包的 exe 总是没法自动提权，网上搜了下，很多人碰到这个问题，但是都没有很完整的解决方案，自己在尝试多次后，都有点要放弃了。 最后突然想起来自己使用的某些工具也是使用了类似的功能，所以问了下这些工具的打包流程，要了打包脚本看了下，突然了恍然大悟了，没有问题的这个是使用的 pyinstaller 提供的另外一个方式而已，只是会稍微麻烦点，需要单独准备资源文件，然后把资源文件进行嵌入，自己拿来改造优化一下，最终实现了预期效果。 这件事给的教训就是，很多问题，一定要站在前人的肩膀上去看问题，这样可以是事半功倍，当然，拿了别人的解决方案也不能仅仅是拿来主义，需要搞明白其中的原理，方便自己举一反三，或者优化改进。 另外，对于自己在过程中付出了努力、时间和精力的问题，最终解决的时候，还是十分令人激动的，我认为这就是「心流」的感觉。 第三次是解决一个父子窗口联动的问题。这次和第一个问题有点类似，就是有一个实现的效果，明明知道可以实现，但就是不知道怎么去写代码实现，或者说不知道方法怎么合理去利用。 我大概描述一下吧：我新建了一个窗口，是在主窗口上点击按钮后弹出的，现在我要在新窗口修改主窗口的内容，但是一直不知道怎么调用主窗口的控件。 和第一个问题类似，我也知道需要利用父类继承的逻辑来达到效果，但就是不知道怎么去写。 在尝试了多种实现方案，在网上看了所有能看到的资料后，最终还是把问题提交到了 stackoverflow，结局和第一个问题类似，在我提交了问题后不久，自己就又找到了问题的解决方案，仅仅是在自己之前的方法中多增加一个初始化字段： 1self.parent = parent 问题是简单的，道路是曲折的，问题解决了，心情是高兴的，留给自己更大的反思还是对于一些基础的巩固一定要加强，只有某一些理论知识丰富了，后面的实践才能更得心应手。 当然，本次主要想说明的是解决问题的兴奋感，不管问题大小，只要是自己觉得有价值的，那么问题带来的不是挫折、不是困难、不是灾难，是兴奋、激动和「心流」的感觉。 上述问题的详细描述可以 看 stackoverflow。 简单做下总结。 发现问题和解决问题的过程是最有意义的，有些问题解决后才发现原来只是某一点没有想到而已，但是在没有想到之前，这就是一个盲点，而解决这个盲点就是这个过程中最大的意义。 比如最后一个问题，其实我之前也尝试过用父类的方法进行传递和调用，但是方法不正确，导致结果也不正确，最后就尝试其他方法，最后却还是兜兜转转转回来了。 另外一点感触就是，基础知识太重要了，有些盲点仅仅是因为太注重实用过程，所以疏于基础的巩固，那么一些很基础的特性可能就不会被想到，那么导致的就是问题解决的复杂度提高了，比如第一个问题的 ignore 参数问题，理论来说，是个函数的基本参数而已，不应该因此耗费太多时间。 最后一点，「问题」不仅仅是「问题」而已，他是一个契机、一个场景、一个过程、一种经历，只有经历了「问题」，才能享受到解决问题的「心流」的感觉。 人生不也是如此？ Enjoy it!]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>驱动力</tag>
        <tag>python</tag>
        <tag>encoding</tag>
        <tag>问题</tag>
        <tag>心流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你在 Ubuntu 上搭建 Git 服务器]]></title>
    <url>%2Fgit-config-on-ubuntu.html</url>
    <content type="text"><![CDATA[最近在写一些脚本，为了保持连续性，就在家也抽空赶进度，所以碰到了代码同步的问题，目前想到的方法有三个： 使用云盘，这个拿来即用，但是因为云盘还存放了其他一些东西，总是实时同步不太妥当；使用 SVN，传统的代码托管工具，一直在用；使用 Git，最新的分布式代码托管工具，据说很强大。 最后决定使用 Git，主要是学习下最新的技术。下面是操作步骤，做记录的同时也给其他同学做个指引： 先说下环境： 服务端： Ubuntu 16.04 x64客户端： Windows7 x64 服务端配置先使用如下命令切到 root 权限进行操作： 1sudo bash 提示输入密码时，输入 root 密码即可。 登录成功后，开始安装 git，命令： 1apt-get install git 提示是否继续时，输入 y 后回车，安装流程继续，并直至安装完成。 接着开始安装 ssh，命令： 1apt-get install openssh-server openssh-client 同样在询问是否继续时，输入 y 后回车，安装会自动完成。 然后我们新建一个 git 专属用户，用户名也叫 git，命令： 1adduser git 新建成功后会提示设置用户密码，请设置一个自己能记住的密码后继续，后续的详细信息可以酌情填写。 下面开始新建 git 仓库，我们选定仓库存放目录为 /srv 下面，仓库名 myfiles.git，所以命令： 1git init --bare /srv/myfiles.git 因为当前用户是 root，为了让后面 git 专用账户能够操作仓库目录，我们需要把仓库目录授权给 git，命令： 1chown -R git:git /srv/myfiles.git/ 客户端操作首先需要下载 Windows 版本的 git，下载地址：点击下载 下载完成后点击安装，并根据提示点击「下一步」，直到安装完成。 在客户端创建一个工作目录，比如我的是 gitdir，在工作目录内右键并点击 「Git Bash Here」。 在弹出的命令后窗口 clone 仓库到本地： 12345678$ git clone git@192.168.252.128:/srv/myfiles.gitCloning into 'myfiles'...The authenticity of host '192.168.252.128 (192.168.252.128)' can't be established.ECDSA key fingerprint is SHA256:zqtjAg+FGfWrT3SCp1Qa2KqhE2UOy3PmudhhrTFlm7A.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.252.128' (ECDSA) to the list of known hosts.git@192.168.252.128's password:warning: You appear to have cloned an empty repository. 注意请把「192.168.252.128」换成自己的服务端 ip，并且在确认时输入的是「yes」，最后输入的是创建 git 用户时候的密码。 为了客户端进行后续的提交操作，我们还需要注明当前机器的用户信息，命令后如下： 12git config --global user.email "you@example.com"git config --global user.name "Your Name" 注册后，commit 的时候会使用这个注册信息来记录操作人信息，然后在使用 git log 时可以看到对应的信息，效果如下图： 123456$ git logcommit ae72bcc89ea8f5d9d3a44f0e00cf35e91a1afce8 (HEAD -&gt; master, origin/master)Author: sylan215 &lt;sylan215@sylan215.com&gt;Date: Wed Oct 18 18:37:41 2017 +0800 测试提交 至此，我们完成整个配置过程。 文件修改并同步到 Git 服务器配置完成后，我们就进入实际使用环节了。 首先我们先修改几个文件，并拷贝到 myfiles 目录下，然后提交到服务端，在 myfiles 下运行提交命令： 123git add .git commit -am "测试提交"git push 带输出的命令行内容： 123456789101112$ git add .$ git commit -am "测试提交"[master (root-commit) ae72bcc] 测试提交 1 file changed, 1 insertion(+) create mode 100644 test.txt$ git pushgit@192.168.252.128's password:Counting objects: 3, done.Writing objects: 100% (3/3), 223 bytes | 223.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To 192.168.252.128:/srv/myfiles.git * [new branch] master -&gt; master 提示输入密码的地方，还是输入的 git 账户的密码。 说明：关于 git 操作的详细命令，请参考 这篇文章 提交成功后，我们在另一台机器上使用命令 git pull 同步最新内容： 1234567891011$ git pullgit@192.168.252.128's password:remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From 192.168.252.128:/srv/myfiles ae72bcc..afad897 master -&gt; origin/masterUpdating ae72bcc..afad897Fast-forward test.txt | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-) 对于多用户的复杂操作，请参考这篇文章 其它配置禁用 git 账户的 shell为了安全考虑，如果需要禁用 git 账户的 shell，可以修改 /etc/passwd 文件： 把其中的 1git:x:1001:1001:git-user,,,:/home/git:/bin/bash 修改为 1git:x:1001:1001:git-user,,,:/home/git:/usr/bin/git-shell 其中 /usr/bin/git-shell 的路径可以通过命令 which git-shell 获得。 使用公匙和私匙实现免密效果上面我们使用的过程中每次都需要输入 git 用户的密码才能和服务端交互，这样会很麻烦，这时候我们可以配置公私匙来实现免密。 首先，需要在客户端生成公私匙： 1ssh-keygen -t rsa 回车后会提示输入私匙的密码，如果要免密就直接回车，否则自定义一个密码(如果自定义了密码，则每次 push 和 pull 时填入的是设置的密码)。 命令执行成功后，会在当前用户目录的.ssh文件夹(Windows 目录是 X:\Users{username}.ssh， Linux 是 /home/{username}/.ssh)生成文件「id_rsa」和「id_rsa.pub」，其中 .pub 文件就是公匙，另一个是私匙。 把文件「id_rsa.pub」拷贝到服务端，并使用如下命令进行设置： 123mkdir /home/git/.sshcp /home/currentuser/Desktop/id_rsa.pub /home/git/.ssh/authorized_keyschown -R git:git /home/git/.ssh 说明，如果 authorized_keys 文件不存在，可以使用 cp 命令，否则请使用 cat 命令追加，比如： 1cat /home/currentuser/Desktop/id_rsa.pub &gt;&gt; /home/git/.ssh/authorized_keys 为了保证配置生效，还需要查看 /etc/ssh/sshd_config 文件中的如下设置是否开启： 1AuthorizedKeysFile %h/.ssh/authorized_keys 是否被注释掉了，如果是，则需要把前面的 # 去掉，并重启 ssh 服务(命令 service ssh restart)。 全部配置完毕后，我们试试效果： 12$ git pullAlready up-to-date. 看，这次没有提示输入密码了吧，免密设置生效。 非 22 端口连接 Git在 .ssh 配置目录现在 config 文件，内容为： 12host ip地址port 端口名 config 配置文件在 Windows 和 Mac 系统的位置为：X:/users/username/.ssh 目录，其中 X 为系统盘， username 为当前登录用户名； 如果是 liunx 系列系统，位置为 /home/username/.ssh 目录，其中 username 为当前登录用户名。]]></content>
      <categories>
        <category>environment</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>环境</tag>
        <tag>git server搭建</tag>
        <tag>ubuntu git server</tag>
        <tag>搭建git lab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底搞懂 Python 编码]]></title>
    <url>%2Fpython-coding.html</url>
    <content type="text"><![CDATA[因为我们的中文，导致 Python 使用过程中的各种编码问题，如果不清楚其中的关联关系，那么这就一直是个大坑，不是懵逼就还是懵逼，所以就目前碰到的情况彻底梳理下关系和区别，以作备忘。先说下涉及编码格式的几个地方： 脚本字符编码：就是经常在脚本文件开头看到的 # -*- coding: utf-8 -*-，如果使用 Python2，没有显式声明的话默认使用 ASCII 格式，Python3 默认使用 utf-8 格式； 解释器字符编码：可以通过函数 sys.getdefaultencoding() 查看，Python2 默认是 ASCII，Python3 默认使用 utf-8； 脚本文件存储编码：就是 py 脚本文件本身在物理介质上面的存储格式，通常有 ASCII、GBK、utf-8 等格式。 下面我们把上述编码分别在脚本中进行组合使用后，再使用 Python2.6 和 Python3.4 运行，看看实际都什么效果。 1.默认脚本文件编码 + 文件存储使用 gbk脚本内容：1234import sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果如下，提示gbk 编码字符 \xd6 非 ASCII 字符：123&gt; python26 test_gbk.py File "test_gbk.py", line 4SyntaxError: Non-ASCII character '\xd6' in file test_gbk.py on line 4, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details 使用 Python3.4 运行的结果如下，提示gbk 编码字符 \xd6 非 utf-8 字符：123&gt; python26 test_gbk.py File "test_gbk.py", line 4SyntaxError: Non-UTF-8 code starting with '\xd6' in file test_gbk.py on line 4, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details 结论：默认的 gbk 编码中文，Python2的解释器字符编码(ASCII)和 Python3的解释器字符编码(utf-8)格式都没法识别，因为 ASCII 编码不包含中文，而 utf-8 是 3 字节编码，gbk 是 2 字节编码，所以都识别不了了。 2.脚本文件编码 gbk + 文件存储使用 gbk在刚才的脚本头部显式声明脚本文件编码格式为 gbk：123456#coding:gbkimport sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果：123&gt; python26 test_gbk.pyascii中文 使用 Python3.4 运行的结果：123&gt; python34 test_gbk.pyutf-8中文 结论：文件使用的 gbk 格式存储，同时显式声明了脚本文件编码为 gbk，Python2 和 Python3 都可以正常处理。 3.脚本文件编码 utf-8 + 文件存储使用 gbk在刚才的脚本头部显式声明脚本文件编码格式为 utf-8：123456# -*- coding: utf-8 -*-import sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果正常：123&gt; python26 test_gbk.pyascii中文 使用 Python3.4 运行的结果如下，提示尝试使用 utf-8 解码字符 0xd6 时异常：123&gt; python34 test_gbk.pyFile "test_gbk.py", line 6SyntaxError: (unicode error) 'utf-8' codec can't decode byte 0xd6 in position 0: invalid continuation byte 结论：文件使用的 gbk 格式存储，同时显式声明了脚本文件编码为 utf-8时，但是 Python2 在 Windows 平台还是使用 gbk 进行输出，所以解析正常，而 Python3 使用 utf-8 所以解析异常。 4.默认脚本文件编码 + 文件存储使用 utf-8去掉之前脚本头部的声明，然后使用 utf-8 格式存储文件(注意，不能在刚才的文件基础上强制修改存储编码，强制转换会出现中文乱码的问题，建议先新建一个 utf-8 格式的文件，然后再输入中文)：1234import sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果如下，ASCII 也识别不了 utf-8 格式的字符 \xe4：123&gt; python26 test.py File "test.py", line 4SyntaxError: Non-ASCII character '\xe4' in file test.py on line 4, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details 使用 Python3.4 运行的结果，可以正常识别，因为 Python3 默认使用 utf-8 编码：123&gt; python34 test.pyutf-8中文 结论：默认的 utf-8 编码中文，Python2 会默认使用 ASCII 读取，所以没法识别，Python3 可以正常识别。 5.脚本文件编码 gbk + 文件存储使用 utf-8脚本头部显式声明脚本文件编码格式为 gbk，同时使用 utf-8 格式存储文件：12345#coding:gbkimport sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果如下，使用 gbk 根本读取不了 utf-8 格式任何内容：123&gt; python26 test.pyFile "test.py", line 6SyntaxError: 'gbk' codec can't decode bytes in position 9-10: illegal multibyte sequence 使用 Python3.4 运行的结果如下，其实和上面错误一样，但是提示更直接了：123&gt; python34 test.pyFile "test.py", line 1SyntaxError: encoding problem: gbk 结论：默认的 utf-8 编码中文，如果显式指定使用 gbk 读取，Python2 和 Python3 都没法做到。 6.脚本文件编码 utf-8 + 文件存储使用 utf-8脚本头部显式声明脚本文件编码格式为 utf-8，同时使用 utf-8 格式存储文件：12345# -*- coding: utf-8 -*-import sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果如下，虽然读取正确了，但是 Python2 在 Windows 系统会默认使用 gbk 对中文进行解码，所以输出乱码：123&gt; python26 test.pyascii涓枃 使用 Python3.4 运行的结果正常：123&gt; python34 test.pyutf-8中文 结论：虽然文件存储编码和脚本文件编码都是 utf-8，但是 Windows 平台上，Python2 会按 gbk 解析中文，所以会输出乱码，可以在中文前面加 u 来解决u&#39;中文&#39;，或者显式使用 utf-8 进行一次 decode。 汇总下验证结果，可以得到如下的表格： 不同组合下 Python3 和 Python2 处理结果 Python3 Python2 默认脚本文件编码 + 文件存储使用 gbk SyntaxError，解析错误 SyntaxError，解析错误 脚本文件编码 gbk + 文件存储使用 gbk 正常输出中文 正常输出中文 脚本文件编码 utf-8 + 文件存储使用 gbk SyntaxError，解析错误 正常输出中文 默认脚本文件编码 + 文件存储 utf-8 正常输出中文 SyntaxError，解析错误 脚本文件编码 gbk + 文件存储使用 utf-8 SyntaxError，解析错误 SyntaxError，编码错误 脚本文件编码 utf-8 + 文件存储使用 utf-8 正常输出中文 中文输出乱码 总结下结论： 如果使用 Python2 请一定要使用 gbk 格式存储文件； 如果使用 Python2 尽可能使用 gbk 存储文件且显式声明脚本文件编码为 gbk，方便后续兼容 Python3； 如果使用 Python3 不管使用什么格式存储文件，但请一定保证显式声明脚本文件编码和存储格式一致； 不管是使用 Python2 还是 Python3，保持显式声明脚本文件编码的好习惯； 如果脚本有跨平台需求，推荐使用 Python3 + 脚本文件编码 utf-8 + utf-8 格式存储文件的组合；]]></content>
      <categories>
        <category>programming</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>decode</tag>
        <tag>encode</tag>
        <tag>编码</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python2 和 Python3 中默认编码的差异]]></title>
    <url>%2Fpython-defaultencode.html</url>
    <content type="text"><![CDATA[最近在使用 Python3.4 做一些脚本实现，发现对于编码的处理上和 Python2.6 有很大的不同，就此机会把相关知识做个梳理，方便需要的时候查阅。先说下概念和差异： 脚本字符编码：就是解释器解释脚本文件时使用的编码格式，可以通过 # -\*- coding: utf-8 -\*- 显式指定解释器字符编码：解释器内部逻辑过程中对 str 类型进行处理时使用的编码格式Python2 中默认把脚步文件使用 ASCII 来处理(历史原因请 Google)Python2 中字符串除了 str 还有 Unicode，可以用 decode 和 encode 相互转换Python3 中默认把脚步文件使用 UTF-8 来处理(终于默认就支持中文了，赞)Python3 中文本字符和二进制分别使用 str 和 bytes 进行区分，也是使用 decode 和 encode 进行相互转换 关于默认脚本字符编码，因为对脚步文件处理的默认编码格式变了，所以很多针对内容的处理，都发生了变化，比如下面这个脚本。1234import sysprint(sys.getdefaultencoding())print('中文') 使用 Python3.4 解释器运行结果如下：123&gt; python34 test.pyutf-8中文 使用 Python2.6 解释器运行结果如下：123&gt; python26 test.py File "test.py", line 4SyntaxError: Non-ASCII character '\xe4' in file test.py on line 4, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details 使用 Python2.6 报错就是因为第一条说的「Python2 中默认把脚步文件使用 ASCII 来处理」，但是脚步文件包含了中文，ascii 又没有覆盖中文，所以报错。如果我们把脚步稍作修改：123456# -*- coding: utf-8 -*-import sysprint(sys.getdefaultencoding())print('中文') 增加了脚本字符编码的说明，再次使用 Python2.6 解释器运行结果为：123&gt; python26 test.pyascii涓枃 因为明确指定了脚步文件编码格式为 utf-8，所以读取没问题，也就是说如果 Python2 脚本文件中包含了非 ASCII 字符时，一定要显式指定脚步文件编码格式，对于 Python3 因为默认的脚步文件编码格式就是 utf-8，所以没有这个问题(后面会有文章详细讨论这个问题)。 但是我们回头看下刚才的输出，结果显示为乱码。 乱码就涉及到另一个我们要说的不同点解释器字符编码，因为我们定义了 utf-8 格式读取脚步内容，但是因为 Python2.6 在 Windows 平台上，默认是使用 gbk 对字符进行 decode 输出，不信你看：1234567891011121314&gt; python26ActivePython 2.6.6.15 (ActiveState Software Inc.) based onPython 2.6.6 (r266:84292, Aug 24 2010, 16:01:11) [MSC v.1500 32 bit (Intel)] onwin32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; s='中文'&gt;&gt;&gt; s'\xd6\xd0\xce\xc4'&gt;&gt;&gt; s.decode('gbk').encode('utf-8')'\xe4\xb8\xad\xe6\x96\x87'&gt;&gt;&gt; print('\xd6\xd0\xce\xc4')中文&gt;&gt;&gt; print('\xe4\xb8\xad\xe6\x96\x87')涓枃 完整描述下上面乱码出现的过程：使用指定的脚本文件编码 utf-8 格式读取了「中文」，读取到的字符串内容为 ‘\xe4\xb8\xad\xe6\x96\x87’，然后输出时 Python2.6 的解释器使用默认解释器字符编码 gbk 格式对读取内容进行 encode 输出，但是之前 utf-8 是 3 个字节长度表示一个中文，而 gbk 是用 2 个字节长度来表示中文，所以之前的 2 个中文，在输出的时候就按照 3 个中文进行编码(encode)，当然就乱码了，仔细看那个乱码，就是 3 个字。 我们再用代码验证下上面说的内容：12345678910111213# -*- coding: utf-8 -*-import sysprint(sys.getdefaultencoding())print('中文')print('\xe4\xb8\xad\xe6\x96\x87')print('\xe4\xb8\xad\xe6\x96\x87'.decode('gbk', 'ignore'))print('\xd6\xd0\xce\xc4'.decode('gbk').encode('utf-8'))print('中文'.decode('utf-8'))print('\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8'))print('\xd6\xd0\xce\xc4')print('\xd6\xd0\xce\xc4'.decode('gbk')) 看看输出结果：12345678910&gt; python26 test.pyascii涓枃涓枃涓枃涓枃中文中文中文中文 很明显 gbk 格式解码的十六进制字符正常输出为中文了，显式使用 utf-8 对 utf-8 格式的十六进制字符进行 decode 也输出正常了。 同理，还可以看到另外 2 个现象： 把 py 文件用 utf-8 格式存储，并且包含「中文」字样时，如果使用 gbk 格式打开，也是看到「中文」显示的乱码和上面程序输出的一致；如果把 py 文件使用 gbk 格式存储，这时候 print(&#39;中文&#39;) 也显示正常了； 乱码的终极原因就是：对同一个字符串的 encode 和 decode 编码格式不一致。 上面说的这个问题，如果文件存储和脚本文件编码都使用 utf-8 时，使用 Python3.4 是没有问题的，因为 Python3 默认的解释器字符编码是 utf-8 了，默认就可以处理中文了。 总结下结论： Python2 脚步文件尽量使用 gbk 格式存储；同理 Python3 脚步文件尽量使用 utf-8 格式存储； Python2 脚步如果带有中文字符时，请务必在脚本开头声明能支持中文的脚本文件编码； Python2 中对同一个字符串的 encode 和 decode 编码格式请保持一致； 说明：本次所有测试脚本文件均保存为 utf-8 格式]]></content>
      <categories>
        <category>programming</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>decode</tag>
        <tag>encode</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由 Python2 和 Python3 中 socket.inet_aton() 实现不同引发的血案]]></title>
    <url>%2Fpython-socket-inet-aton.html</url>
    <content type="text"><![CDATA[这几天在做一个功能实现的时候，需要把别人用 Python2.6 写好的脚步转成 Python3.4 实现，大部分地方转化都没啥问题，但是在 socket.inet_aton() 转化的过程中出了点问题，花费我不少的精力去解决，先做个记录备忘，同时给后续需要的人做个提醒。首先说一下，我在解决这个问题前期的思路有点问题，所以请关注最后的总结。 需求目的：把一个 ip 地址使用 socket.inet_aton() 转化后和一个字符串组合，然后算出 MD5。 下面是 Python2.6 的实现代码：1234567891011#!python2# -*- coding: utf-8 -*-import socketimport hashlibif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' ip_md5 = hashlib.md5(socket.inet_aton(ip) + base_str).digest().encode('hex') print(ip_md5) 运行后的输出结果为： fc138bb4748a18f885cc321c2c6396e2 如果原封不动的使用 Python3.4 运行后，报错如下：123456Traceback (most recent call last): File "socket34.py", line 25, in &lt;module&gt; test1() File "socket34.py", line 10, in test1 ip_md5 = hashlib.md5(socket.inet_aton(ip) + base_str).digest().encode('hex')TypeError: can't concat bytes to str 提示说的是，socket.inet_aton(ip) 的返回值是 bytes 类型，所以不能和 str 类型的 base_str 直接进行连接操作。也就是说 Python2.6 和 python3.4 中对于 socket.inet_aton(ip) 的实现是有差异的，查官方文档吧。python2.6文档说明： socket.inet_aton(ip_string)Convert an IPv4 address from dotted-quad string format (for example, ‘123.45.67.89’) to 32-bit packed binary format, as a bytes object four characters in length. python3.4 文档说明： socket.inet_aton(ip_string)Convert an IPv4 address from dotted-quad string format (for example, ‘123.45.67.89’) to 32-bit packed binary format, as a string four characters in length. 好吧，返回值类型不同，为了保证和原脚本逻辑一致，我就做个转化，把 bytes 主动转换为 str 类型再连接，修改后的代码如下：123456789101112#!python3# -*- coding: utf-8 -*-import socketimport hashlibif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' str_md5 = socket.inet_aton(ip).decode('gbk') + base_str ip_md5 = hashlib.md5(str_md5).digest().encode('hex') print(ip_md5) 代码通过 decode 把 bytes 使用 gbk 的方式解码成 str，至于为什么用 gbk，是因为我对比了下，只有 gbk 编码方式解码后的输出才和 python2.6 中的 str 返回值结果一致。 行，赶紧运行一把试试看。。。还是报错了，这次的报错内容变了：123456Traceback (most recent call last): File "socket34.py", line 34, in &lt;module&gt; test1() File "socket34.py", line 12, in test1 ip_md5 = hashlib.md5(str_md5).digest().encode('hex')TypeError: Unicode-objects must be encoded before hashing 看起来 hashlib.md5() 在 Python2.6 和 Python3.4 中的实现也有差异，继续看文档。python2.6文档说明： You can now feed this object with arbitrary strings using the update() method. python3.4 文档说明： You can now feed this object with bytes-like objects (normally bytes) using the update() method. 依然是编码格式的问题，Python2.6 中参数传入的是 str，但是 Python3.4 中参数需要传入 bytes，那就继续转码吧。再次转码后的代码如下：123456789101112#!python3# -*- coding: utf-8 -*-import socketimport hashlibif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' str_md5 = socket.inet_aton(ip).decode('gbk') + base_str ip_md5 = hashlib.md5(str_md5.encode('gbk')).digest().encode('hex') print(ip_md5) 运行后再次报错：123456Traceback (most recent call last): File "socket34.py", line 33, in &lt;module&gt; test1() File "socket34.py", line 11, in test1 ip_md5 = hashlib.md5(str_md5.encode('gbk')).digest().encode('hex')AttributeError: 'bytes' object has no attribute 'encode' 好吧，继续看文档。python2.6文档说明： hash.digest()Return the digest of the strings passed to the update() method so far. This is a string of digest_size bytes which may contain non-ASCII characters, including null bytes. python3.4 文档说明： hash.digest()Return the digest of the data passed to the update() method so far. This is a bytes object of size digest_size which may contain bytes in the whole range from 0 to 255. 这次更严重，encode() 直接用不了，换方法吧，更新后的代码如下：12345678910111213#!python3# -*- coding: utf-8 -*-import socketimport hashlibimport binasciiif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' str_md5 = socket.inet_aton(ip).decode('gbk') + base_str ip_md5 = binascii.hexlify(hashlib.md5(str_md5.encode('gbk')).digest()).decode() print(ip_md5) 运行后的输出结果： fc138bb4748a18f885cc321c2c6396e2 终于得到了最终结果，激动，不过再回头一看，如果知道这几个函数的使用方式的话，就不需要 decode() 然后又 encode()，比如稍微优化后的代码如下：12345678910111213#!python3# -*- coding: utf-8 -*-import socketimport hashlibimport binasciiif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' str_md5 = socket.inet_aton(ip) + base_str.encode() ip_md5 = binascii.hexlify(hashlib.md5(str_md5).digest()).decode() print(ip_md5) 总结： Python3 新增了 bytes 类型，对于 bytes 的转换逻辑要特别清楚，这地方涉及了编码类型，要特别关注； 在使用一些函数前，一定要搞清楚这个函数的具体实现，必须清楚的知道使用了这个函数是什么效果，而不仅仅是看到暂时的效果，或者经验主义的去调用(上面例子的最后一步，其实我一开始不是用的 binascii，而是用的现成的 md5 转换函数，导致 encode() 成了 utf-8 格式，而浪费了不少时间去定位)； 解决问题过程中，思路一定要清晰，不能靠猜，越猜越错； 先弄明白问题的根本原因，直接从根源上去解决，比一步步的就错解错，效果更好。]]></content>
      <categories>
        <category>programming</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>decode</tag>
        <tag>encode</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过度设计]]></title>
    <url>%2Fguodusheji.html</url>
    <content type="text"><![CDATA[今天来说点专业领域的话题，关于「过度设计」。 这里说的「过度设计」指的是人为的创造了过多非必要的需求实现。 打个最简单的比方，我们最常用的 office 套件，有多少人真正的使用过其中超过十分之一的功能实现？就算不使用，又有多少人知道 office 究竟可以实现哪些功能？在我知道的人里面，应该是很少人知道的。 可以因为 excel 写一本(好几本 + 不同版本)厚厚的使用秘籍，这也是没谁了，诚然，这也让一部分人依赖这个神奇的软件生存了下来。这不是贬损微软的意思哈，只是觉得这个例子很有说服力。 其实类似 office 这种过度设计的情况，在当前很多的软件实现中都很常见，经常会发现一个软件的很多功能都是需求人员意yin出来的结果。 比如今天用的麦当劳最新的触摸屏在线点餐系统，每次点击操作后，看着满屏推荐的美食，竟然不知道下一步如何操作，在我自以为是计算机专人人士的眼里，依然傻傻分不清，其中一个原因是，操作结果中推荐的内容太多，经常搞不清自己点了啥，或者是以为点错了啥。 推荐系统不是没有必要，如何做才是最重要的，比如传说中的 google 的推荐系统是首屈一指的，大家也比较信服和接受它的推荐。而麦当劳的推荐不是结果不恰当，而是显示的位置和方式不对，主次颠倒，体验大打折扣。 当然，这个系统作为刚需来说，大家还是会去适应它并使用它，但是想想，如果不是依附这个强需求，这样的产品设计谁会去用它。 再说一个正面的例子吧，软件安全界比较有名的几个工具：冰刃、pchunter 等，只是从 UI 上看，真的没有什么酷炫的实现，但是它们的功能强大到安全界的人几乎无人不知无人不晓，这不是酷炫的显示效果就能达到的，而是因为它的每个「丑陋」的按钮后面都是一个很实用的功能，所以能一直传承至今，并被奉为经典。 不过话说回来，用户需求其实是个伪命题，很多用户其实根本不清楚自己的需求，就像很多人不知道自己生活的目的和意义一样，但是有一样东西确实恒古不变的，那就是人性。 基于人性的需求的实现的例子可就多了，脑白金记得吧，它是满足人们需求的不，不是，它满足的是人性；各种sex网站，它是满足人们需求的不，这个其实也算是吧，但是说它是满足人性会更恰当；各种题型的游戏，这个更是完全从人性出发，可以算是最早的虚拟现实，让人性在游戏中得到另类的放大和发挥；然后人们熟悉的微信，也是必然的结果，虽然我一直认为他的各种设置入口简直不要太难找，但是他的主要功能是人们所需要和诉求的。所有这些，都在他们各自的领域大放异彩，因为他们各自在某种方面满足了人性的诉求。 再说回来之前的 office 套件，它是工具，基于人性出发的话，满足工作需要的工具就是好工具，所以虽然它功能繁复，但是各类人都可以从中找到适合自己的功能，从而满足了不同人群的使用需要，从这个意义上说，它是一个好工具。而如果从需求开发投入量说，应该还是有优化空间的。比如做个通用版，只需要把最常用功能进行提炼，一方面减少软件体积，一方面减少维护成本，而高级技能版，则可以为各类专业人士去设计了，但是目前的垄断地位可能没有让他们去改进优化的动力。 再说说麦当劳点餐系统，满足了人们要求快的需求，但是推荐逻辑是反人性的，同样因为没有更好的选择而被接受。 安全工具，满足了人们针对工具使用的需求和目的，同时也满足了人们物超所值的人性，被传播是当然的了。 最后借用伟大的腾讯对于产品设计的至高理念作为总结，需求设计的最高目标就是「不要让用户思考」。]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>过度</tag>
        <tag>产品</tag>
        <tag>用户</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天时地利人和]]></title>
    <url>%2Ftiandiren.html</url>
    <content type="text"><![CDATA[《孟子·公孙丑下》曰：「天时不如地利，地利不如人和」。 《孙膑兵法·月战》曰：「天时、地利、人和，三者不得，虽胜有殃」。看，早在几千年前，我们的先知圣人就已经总结出来这么个真理，而且言简意赅，浅显易懂，但是直到今天，却仍然没有人太在意。 而当 1998 年马尔科姆·格拉德威尔写出了《异类》时，通过整本书的一半篇幅来描述「天时地利人和」的重要性，终于让人类觉醒了。 我们先看看这本书都说了些什么。 书中总共分了两大章节，第一章总结下来讲的就是「天时地利人和」，第二章节主要讲的是「社会继承对个人的影响」。 今天我们主要说说第一章的内容。第一章分别通过几个小节来分别举例说明了「天时地利人和」在现实生活中的体现。下面我们拿几个例子来说明。 先说说众所周知的比尔·盖茨吧，我们之前所了解的盖茨，都是从他退学开始，我们并没有去了解过他退学之前的事情。其实在他退学前，因为「天时」的原因，在他年龄刚好合适的时候出现了非打卡式计算机，而因为「地利」，他可以经常方便的到学校去使用最先进的计算机设备，而「人和」就是他在退学前，几乎完成了自己的 10000 小时积累。 因为有了这些凑巧的「天时地利人和」，才能看到目前我们眼中的比尔·盖茨。如果之前的过程中少了任何一个环节，历史将会大不一样，比如盖茨早出生或晚出生5到10年，时间窗口就可能过去，如果盖茨不是住在学校边上，或者不认识一个老爸赞助了学校计算机的同学，那么他不可能很快的越过自己 10000 小时积累的坎等等，所有这些都是一环扣一环。 另一个例子如犹太人鲍格妮特，他在合适的时间来到了美国，在合适的地方—一个可以让他的市场调查能力和他老婆的缝纫能力得到应用的地方，充分发挥了他和他老婆早已娴熟的技能，天时 + 地利 + 人和，让他可以在当时的场景下做的风生水起，最后的结果也当然是功成名就。 作者最后总结出来的关键点是：「出生的时间对」、「有人告诉你怎么做」、「自己知道去努力」，刚好对应的就是「天时地利人和」了。 这让我也想起自己入职目前所在公司的经历。 09 年因为个人原因打算从当时的单位离职，所以找同学帮忙内推了一下，10 年 1 月 28 号接到猎头电话时，在同学介绍的单位已经一面通过了，抱着试试看的心态，去了猎头介绍—也就是目前的单位来谈了谈，一面结束后很长时间没有结果通知，期间又继续到同学的单位二面，然后等体检通知，期间又来目前单位二面 + HR面，接着又是漫长的等待，还好这次换工作并没有特别着急，所以继续着同学单位的流程，而就在我体检结束的当天，3 月 8 号，目前单位的 offer 下来了，在经历一个多月漫长的时间后，最终还是接受了目前单位的 offer。 来看看，刚好在我准备离职时收到了猎头电话，之前和之后的都被我拒绝了，刚好因为这次换工作并不着急，有足够的时间等 offer，所以才能熬过漫长的一个多月反馈周期，刚好因为自己目前做的项目和新公司项目匹配度高，所以在面试过程中也起到了相当重要的作用。 天时、地利、人和，全了，事情也就水到渠成了。 在合适的时间，抓住合适的机会，并为此付出努力，那么离做成事情也就不远了，自勉。]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>天时</tag>
        <tag>地利</tag>
        <tag>人和</tag>
        <tag>异类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 三大特性之多态]]></title>
    <url>%2Fjava-duotai.html</url>
    <content type="text"><![CDATA[Java 三大特性之多态：对象有多种表现形式，具体最终使用哪种形式由最后运行时情况决定。使用多态必须要达到三个条件： 一个就是需要使用继承 一个就是涉及方法的重写 最后一个就是需要进行向上转型 前期绑定：也叫编译时绑定，主要表现类型是重载(overloading)，比如一个类中有一个或多个名称相同的方法，但是他们参数不同。 举个例子：1234567891011121314public class TestClass &#123; public static void main(String[] str) &#123; testMethod(10); testMethod("This is a string"); &#125; public static void testMethod(int iRet) &#123; System.out.println("int simple"); &#125; public static void testMethod(String sRet) &#123; System.out.println("string simple"); &#125;&#125; 输出结果： int simplestring simple 后期绑定：也叫运行时绑定，主要表现类型就是重写(overriding)，比如子类重写了父类的方法。 举个例子：123456789101112131415161718public class TestClass &#123; public static void main(String[] str) &#123; Father testMethod = new Son(); testMethod.getResult(); &#125;&#125;class Father &#123; public void getResult() &#123; System.out.println("I am a Father"); &#125;&#125;class Son extends Father &#123; public void getResult() &#123; System.out.println("I am the Son"); &#125;&#125; 输出结果为： I am the Son 只有普通的方法调用是可以多态的，直接访问的成员变量是不支持多态的。为了避免混淆，可以把成员变量设置为 private 属性。 举个例子：1234567891011121314151617181920212223public class TestClass &#123; public static void main(String[] str) &#123; Father testMethod = new Son(); System.out.println("testMethod.notMethod = " + testMethod.notMethod + ", testMethod.getNotMethod() = " + testMethod.getNotMethod()); &#125;&#125;class Father &#123; public int notMethod = 0; public int getNotMethod() &#123; return notMethod; &#125;&#125;class Son extends Father &#123; public int notMethod = 1; public int getNotMethod() &#123; return notMethod; &#125;&#125; 输出结果： testMethod.notMethod = 0, testMethod.getNotMethod() = 1 **从结果可以看出来，testMethod.notMethod 获取的是父类的变量的值，而不是子类的，但是 testMethod.getNotMethod() 则是获取子类的方法的返回值。 总结下就是，static 方法和 final 方法属于前期绑定，子类无法重写 final 方法，静态和非静态的成员变量都属于前期绑定。除了 static 方法和 final 方法（ private 属于 final 方法）之外的其他方法属于后期绑定，运行时能判断对象的类型进行绑定。** 来个例子：123456789101112131415161718public class TestClass &#123; public static void main(String[] str) &#123; Father testMethod = new Son(); testMethod.getResult(); &#125;&#125;class Father &#123; public static void getResult() &#123; System.out.println("I am a Father"); &#125;&#125;class Son extends Father &#123; public static void getResult() &#123; System.out.println("I am the Son"); &#125;&#125; 输出结果为： I am a Father 当继承和向上转型同时存在时，函数实现会遵循多态原则进行实际的调用，调用顺序为：this.method(class)、super.method(class)、this.method((super)class)、super.method((super)class)。 来个例子：1234567891011121314151617181920212223242526272829303132333435363738394041public class TestClass &#123; public static void main(String[] str) &#123; Father oneTest = new Father(); Son twoTest = new Son(); Father threeTest = new Son(); Son fourTest = new GrandDaughter(); //this.method(class) threeTest.method(oneTest); //super.method(class) threeTest.method(twoTest); //this.method((super)class) threeTest.method(threeTest); //super.method((super)class) threeTest.method(fourTest); &#125;&#125;class Father &#123; public void method(GrandDaughter grandDaughter) &#123; System.out.println("I am the Granddaughter in Father"); &#125; public void method(Son son) &#123; System.out.println("I am the son in Father"); &#125; public void method(Father father) &#123; System.out.println("I am the Father in father"); &#125;&#125;class Son extends Father &#123; public void method(Father father) &#123; System.out.println("I am the Father in Son"); &#125;&#125;class GrandDaughter extends Son &#123;&#125; 输出结果为： I am the Father in SonI am the son in FatherI am the Father in SonI am the son in Father 构造器方法默认都是 static 属性的，所以不支持多态。当时基类的构造器总是在子类的构造过程中被调用，而且按照继承层次逐级依次调用。 举个例子：1234567891011121314151617181920212223public class TestClass extends GouZaoQiThree&#123; public static void main(String[] str) &#123; new TestClass(); &#125;&#125;class GouZaoQiOne &#123; GouZaoQiOne() &#123; System.out.println("This is GouZaoQiOne"); &#125;&#125;class GouZaoQiTwo extends GouZaoQiOne&#123; GouZaoQiTwo() &#123; System.out.println("This is a GouZaoQiTwo"); &#125;&#125;class GouZaoQiThree extends GouZaoQiTwo&#123; GouZaoQiThree()&#123; System.out.println("This is GouZaoQiThree"); &#125;&#125; 输出结果： This is GouZaoQiOneThis is a GouZaoQiTwoThis is GouZaoQiThree 好了，作为 Java 的三大特性之一，多态在实际项目过程的使用会非常广泛，上述说明还需要在实践中多加锻炼才行。]]></content>
      <categories>
        <category>programming</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>封装</tag>
        <tag>继承</tag>
        <tag>多态</tag>
        <tag>java三大特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 三大特性之继承]]></title>
    <url>%2Fjava-jicheng.html</url>
    <content type="text"><![CDATA[前两天我们说了 Java 三大特性之封装，今天主要说说三大特性之继承。下面我们会通过继承的特点和对应的例子来分别进行说明。 子类拥有父类非 private 的属性，方法。子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。子类可以用自己的方式实现父类的方法。 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestClass &#123; public static void main(String[] str) &#123; Son simple = new Son(); simple.method(); simple.printStr(); simple.method("simple"); &#125;&#125;class Father &#123; //父类的非private属性，子类也可以访问和使用 public String str = "Simple"; Father() &#123; System.out.println("This is the Father's " + str); &#125; //父类的非private方法，子类可以调用 public void method() &#123; System.out.println("This is the Father's method"); &#125; public void method(String strs) &#123; System.out.println("This is the Father's method with param"); &#125;&#125;class Son extends Father &#123; //子类可以拥有自己的属性 private String ownStr = "ownStr"; Son() &#123; super(); System.out.println("This is the Son's " + super.str); &#125; //子类可以拥有自己的方法 public void printStr() &#123; System.out.println("This is the " + "Son's method"); &#125; //子类可以重写父类的方法 public void method(String strs) &#123; System.out.println("This is the Son's method, " + "which is overriding from Father"); &#125;&#125; ​输出结果： This is the Father’s SimpleThis is the Son’s SimpleThis is the Father’s methodThis is the Son’s methodThis is the Son’s method, which is overriding from Father Java 的类继承是单继承，但是接口可以使用关键字 implements 实现多重继承(例子会在后面讲接口的时候详细说明)。子类会默认调用父类的无参数构造器，但是如果父类没有无参构造器，子类必须要显式的指定父类的构造器(有参数)，而且必须是在子类构造器第一行进行调用。 例子：12345678910111213141516171819202122232425262728293031public class TestClass &#123; public static void main(String[] str) &#123; new GouZaoQiTwo(); new GouZaoQiFour("simple"); &#125;&#125;class GouZaoQiOne &#123; GouZaoQiOne() &#123; System.out.println("This is GouZaoQiOne"); &#125;&#125;class GouZaoQiTwo extends GouZaoQiOne&#123; //子类会默认调用父类的无参数构造器&#125;class GouZaoQiThree &#123; GouZaoQiThree(String str) &#123; System.out.println("This is the gouzaoqi with param."); &#125;&#125;class GouZaoQiFour extends GouZaoQiThree&#123; GouZaoQiFour(String str)&#123; //如果父类没有无参构造器，子类必须要显式的指定父类的构造器(有参数)， //而且必须是在子类构造器第一行进行调用 super(str); System.out.println("This is GouZaoQiFour"); &#125;&#125; 输出结果： This is GouZaoQiOneThis is the gouzaoqi with param.This is GouZaoQiFour 继承后类型支持向上转型，比如 B 继承 A，那么B的实例也属于 A 类型。 例子： 12345678910111213141516171819public class TestClass &#123; public static void main(String[] str) &#123; GouZaoQiTwo gouZaoQiTwo = new GouZaoQiTwo(); //method方法的参数实际要求的类型是GouZaoQiOne， //但是因为GouZaoQiTwo是GouZaoQiOne的子类， //所以可以通过向上转型来满足参数类型的需要 gouZaoQiTwo.method(gouZaoQiTwo); &#125;&#125;class GouZaoQiOne &#123; public void method(GouZaoQiOne gouZaoQiOne) &#123; System.out.println("This is GouZaoQiOne"); &#125;&#125;class GouZaoQiTwo extends GouZaoQiOne&#123;&#125; 继承提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系），慎用继承。 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestClass &#123; public static void main(String[] str) &#123; ZiXingChe ziXingChe = new ZiXingChe("sylan215"); DianDongChe dianDongChe = new DianDongChe("sylan215-1"); ziXingChe.run(); ziXingChe.sleep(); ziXingChe.reboot(); dianDongChe.run(); dianDongChe.sleep(); dianDongChe.power(); &#125;&#125;class ZiXingChe &#123; private String name; ZiXingChe(String name) &#123; this.name = name; System.out.println("This is a " + name); &#125; public void run() &#123; System.out.println("I am a " + this.name + ", I can run"); &#125; public void sleep() &#123; System.out.println("I am a " + this.name + ", I need sleep"); &#125; public void reboot() &#123; System.out.println("I am a " + this.name + ", I need reboot"); &#125;&#125;class DianDongChe &#123; private String name; DianDongChe(String name) &#123; this.name = name; System.out.println("This is a " + name); &#125; public void run() &#123; System.out.println("I am a " + this.name + ", I can run"); &#125; public void sleep() &#123; System.out.println("I am a " + this.name + ", I need sleep"); &#125; public void power() &#123; System.out.println("I am a " + this.name + ", I need power"); &#125;&#125; 输出结果为： This is a sylan215This is a sylan215-1I am a sylan215, I can runI am a sylan215, I need sleepI am a sylan215, I need rebootI am a sylan215-1, I can runI am a sylan215-1, I need sleepI am a sylan215-1, I need power 看看合并后的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TestClass &#123; public static void main(String[] str) &#123; ZiXingChe ziXingChe = new ZiXingChe("sylan215"); DianDongChe dianDongChe = new DianDongChe("sylan215-1"); ziXingChe.run(); ziXingChe.sleep(); ziXingChe.reboot(); dianDongChe.run(); dianDongChe.sleep(); dianDongChe.power(); &#125;&#125;class CheZi &#123; private String name; CheZi(String name) &#123; this.name = name; System.out.println("This is a " + name); &#125; public void run() &#123; System.out.println("I am a " + this.name + ", I can run"); &#125; public void sleep() &#123; System.out.println("I am a " + this.name + ", I need sleep"); &#125;&#125;class ZiXingChe extends CheZi &#123; private String name; ZiXingChe(String name) &#123; super(name); this.name = name; &#125; public void reboot() &#123; System.out.println("I am a " + this.name + ", I need reboot"); &#125;&#125;class DianDongChe extends CheZi &#123; private String name; DianDongChe(String name) &#123; super(name); this.name = name; &#125; public void power() &#123; System.out.println("I am a " + this.name + ", I need power"); &#125;&#125; 输出结果为： This is a sylan215This is a sylan215-1I am a sylan215, I can runI am a sylan215, I need sleepI am a sylan215, I need rebootI am a sylan215-1, I can runI am a sylan215-1, I need sleepI am a sylan215-1, I need power 总结下继承的特点： 子类拥有父类非 private 的属性、方法； 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展； 子类可以用自己的方式实现父类的方法； Java 的类继承是单继承，但是接口可以使用关键字 implements 实现多重继承； 子类会默认调用父类的无参数构造器，但是如果没有默认(无参数)的父类构造器，子类必须要显式的指定父类的构造器(有参数)，而且必须是在子类构造器中做的第一件事； ​继承后类型支持向上转型，比如 B 继承 A，那么B的实例也属于 A 类型; 继承提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系），慎用继承；]]></content>
      <categories>
        <category>programming</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>封装</tag>
        <tag>继承</tag>
        <tag>多态</tag>
        <tag>java三大特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 三大特性之封装]]></title>
    <url>%2Fjava-fengzhuang.html</url>
    <content type="text"><![CDATA[学习Java，必须得了解Java的三大特性，今天就说说三大特性之一的封装。 封装就是把属性私有化，然后提供公共的方法来访问私有属性。 概念性的东西大家上网搜一下就行，下面我们分别举例说明封装的几个好处。 1.可以隐藏一些私有属性和一些实现过程。先看看封装前的代码： 123456789101112131415161718192021public class TestClass &#123; public static void main(String[] str) &#123; Flower newFlower = new Flower(); newFlower.name = "JuHua"; newFlower.chanDi = "China"; newFlower.time = 10; newFlower.xiShui = false; Flower twoFlower = new Flower(); twoFlower.name = "GuiHua"; twoFlower.chanDi = "China"; twoFlower.time = 30 twoFlower.xiShui = false; &#125;&#125;class Flower &#123; public String name;//花名 public int time;//最长花龄 public String chanDi;//产地 public boolean xiShui;//是否喜水&#125; 再看看封装后的代码： 1234567891011121314151617181920public class TestClass &#123; public static void main(String[] str) &#123; Flowers flowerSimple = new Flowers("JuHua", 10, "China", false); Flowers flowerSimple2 = new Flowers("GuiHua", 30, "Juke", false); &#125;&#125;class Flowers &#123; private String name;//花名 private int time;//最长花龄 private String chanDi;//产地 private boolean xiShui;//是否喜水 Flowers(String name, int time, String chanDi, boolean xiShui) &#123; this.name = name; this.time = time; this.chanDi = chanDi; this.xiShui = xiShui; &#125;&#125; 很明显，我们把类的属性给做了隐藏处理，然后使用公共的构造函数提供对外操作的入口，构造函数的实现过程也保持了对外的隐藏。 2.可以对赋值的属性进行一些代码处理，让代码逻辑更准确。 比如上面的例子中，封装前，对属性的初始化赋值是没有做任何兼容处理的，如果设置 newFlower.time = 100000;程序不会报错，但是没有实际应用的意义了，所以也不能满足产品兼容性的要求，但是也没法进一步处理，而通过封装就可以很好的进行这种特殊处理。看代码： 1234567891011121314151617181920212223242526public class TestClass &#123; public static void main(String[] str) &#123; Flowers flowerSimple = new Flowers("JuHua", 100000, "China", false); &#125;&#125;class Flowers &#123; private String name;//花名 private int time;//最长花龄 private String chanDi;//产地 private boolean xiShui;//是否喜水 Flowers(String name, int time, String chanDi, boolean xiShui) &#123; this.name = name; //对传入的参数进行合理性校验，如果是封装前，肯定做不到这个效果 if (time &gt; 10000) &#123; System.out.println("The number is too big"); &#125; else &#123; this.time = time; &#125; this.chanDi = chanDi; this.xiShui = xiShui; &#125;&#125; 输出结果：The number is too big 3.可以在需要修改时只改变封装函数即可。 还拿第一个例子来说，如果是封装前，我们需要把 time 的类型改成 String，那么我们就需要在每个初始化的地方去修改初始化值为 String 类型，但是封装后则只需要做个简单处理即可，看代码： 1234567891011121314class Flowers &#123; private String name;//花名 private String time;//最长花龄，换成String类型了 private String chanDi;//产地 private boolean xiShui;//是否喜水 Flowers(String name, int time, String chanDi, boolean xiShui) &#123; this.name = name; //不修改任何实现，只是把传入的int通过String.valueof进行下类型转换即可 this.time = String.valueOf(time); this.chanDi = chanDi; this.xiShui = xiShui; &#125;&#125; 最后再总结下封装的好处： 1.可以隐藏一些私有属性和一些实现过程；2.可以对赋值的属性进行一些代码处理，让代码逻辑更准确；3.可以在需要修改时只改变封装函数即可。]]></content>
      <categories>
        <category>programming</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>封装</tag>
        <tag>继承</tag>
        <tag>多态</tag>
        <tag>java三大特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 实现文件递归遍历]]></title>
    <url>%2Fpython-wenjianbianli.html</url>
    <content type="text"><![CDATA[今天有个脚本需要遍历获取某指定文件夹下面的所有文件，我记得很早前写过，于是找来看一看，嘿，不看不知道，看了吓一跳，原来之前我竟然用了这么搓的实现。先发出来看看：123456789101112131415161718#遍历获取指定文件夹下面所有文件def getallfiles(dir): if os.path.isdir(dir): filelist = os.listdir(dir) for ret in filelist: filename = dir + "\\" + ret if os.path.isfile(filename): print filename#遍历获取所有子文件夹下面所有文件def getalldirfiles(dir, basedir): if os.path.isdir(dir): getallfiles(dir) dirlist = os.listdir(dir) for dirret in dirlist: fullname = dir + "\\" + dirret if os.path.isdir(fullname): getalldirfiles(fullname, basedir)我是用了 2 个函数，并且每个函数都用了一次 listdir，只是一次用来过滤文件，一次用来过滤文件夹，如果只是从功能实现上看，一点问题没有，但是这…太不优雅了吧。 开始着手优化，方案一：123456789101112#使用listdir循环遍历def getallfiles(dir): if not os.path.isdir(dir): print dir return dirlist = os.listdir(dir) for dirret in dirlist: fullname = dir + "\\" + dirret if os.path.isdir(fullname): getallfiles(fullname) else: print fullname从上图可以看到，我把两个函数合并成了一个，只调用了一次 listdir，把文件和文件夹用 if~else~ 进行了分支处理，当然，自我调用的循环还是存在。 有木有更好的方式呢？网上一搜一大把，原来有一个现成的 os.walk() 函数可以用来处理文件(夹)的遍历，这样优化下就更简单了。 方案二：123456789#使用listdir循环遍历def getallfilesofwalk(dir): if not os.path.isdir(dir): print dir return dirlist = os.walk(dir) for root, dirs, files in dirlist: for file in files: print os.path.join(root, file)只是从代码实现上看，方案二是最优雅简洁的了，但是再翻看 os.walk() 实现的源码就会发现，其实它内部还是调用的 listdir 完成具体的功能实现，只是它对输出结果做了下额外的处理而已。 附上os.walk()的源码：1234567891011121314151617181920212223242526272829303132from os.path import join, isdir, islink# We may not have read permission for top, in which case we can't# get a list of the files the directory contains. os.path.walk# always suppressed the exception then, rather than blow up for a# minor reason when (say) a thousand readable directories are still# left to visit. That logic is copied here.try: # Note that listdir and error are globals in this module due # to earlier import-*. names = listdir(top)except error, err: if onerror is not None: onerror(err) returndirs, nondirs = [], []for name in names: if isdir(join(top, name)): dirs.append(name) else: nondirs.append(name)if topdown: yield top, dirs, nondirsfor name in dirs: path = join(top, name) if followlinks or not islink(path): for x in walk(path, topdown, onerror, followlinks): yield xif not topdown: yield top, dirs, nondirs至于 listdir 和 walk 在输出时的不同点，主要就是 listdir 默认是按照文件和文件夹存放的字母顺序进行输出，而 walk 则是先输出顶级文件夹，然后是顶级文件，再输出第二级文件夹，以及第二级文件，以此类推，具体大家可以把上面脚本拷贝后自行验证。]]></content>
      <categories>
        <category>programming</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>文件</tag>
        <tag>递归</tag>
        <tag>文件夹</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在前面]]></title>
    <url>%2Fxiezaiqianmian.html</url>
    <content type="text"><![CDATA[在毕业十年之后，我终于又开始重新审视自己的人生了，十年是一个不短的时间，甚至可以说毕业后的十年是人生中最宝贵的十年，那这十年里我都做了些什么呢？先是毫无目的的晃荡了 2 年，什么都不会做，就什么都做，从最基本的做起，从自己最不擅长的做起，逼自己做一些不喜欢的事，一直逼到最后自己实在没法忍受，也没法接受自己当时的状态了，终于选择遵从自己内心的选择。 毕业 2 年后，独自一人只身来到北京，开始了新的征程，对比之前的经历，对于新的选择就像找到了自己的归宿，感觉自己一直就应该做这些事，而这一做就是8年多，从懵懂无知到身经百战。 人都是很固执的，特别是当解决了马斯洛需求中最基本的几个需求层次后，那种固执尤其明显。 比如我从 16 年 3 月份开始写公众号了，原因仅仅是因为我高中时候的梦想是当一个「作家」。尽管之前我作文经常跑题，语文总是老大难，尽管工作总是很忙，总是抽不时间来写字，但是这些都没妨碍我的公众号断断续续更新了快一年时间了。 我能清晰记得自己对文字惦记的感觉，记得每写一篇文字后的成就感，记得公众号开通原创和赞赏时候的兴奋，哪怕大多数文字总是很浅显幼稚，哪怕每篇文字的阅读量都很低，但是这些是我喜欢做的，是我自发自愿做的，我仅仅是在试着实现自己的梦想，那种由心自发的感觉真是让人难以忘怀。 在逐渐往「作家」前进的道路上，自己的另一个固执症也发作了：技术。 自己特别喜欢那种专注于技术时的全神贯注的感觉，一心一意只是为了解决或实现某个问题持续不懈的努力，而这种努力是具象化的，努力的结果是直接能体现的，体现出来的就是那一个个饱含心血的作品。 生产作品这个过程中，切实感觉到的技术进步特别有成就感，同时产出的作品被别人使用和评价时，那种成就感更是油然而生，我喜欢并享受那种感觉。 其实十年前，我就坚持过技术的方向，只是因为各种原因没有坚持下去，可以说考虑的太多，或者说太瞻前顾后，或者其他能找出来的一堆原因，总之就是我在还没开始的时候就放弃了，而现在我决定要重新开始了，从十年前中断的地方重新开始了。 开始并不可怕，结束也不可怕，可怕的是失去在过程中坚持下去的动力，而这篇文章就作为这件事的开始，希望是对自己这个决定的见证，不管什么时候结束，只是为了看看自己能坚持多久，并尽可能的享受这个过程。 这里用「技术」这个词其实还是有点概括了，其实我主要想说的是编程技术，我计划捡起之前放弃过的编程，不管是作为副业还是主业，都一直努力的深究下去，而这个公众号就是记录自己努力的过程，我会把自己学习的成果尽可能的总结后产出。 每个人的一生中，能有多少个十年，我希望自己的下一个十年，依然是一个饱含激情、积极向上、勇往直前、努力奋进的十年。 不管结果如何，我都一直在努力。 So，Don’t be afraid， Just do it!]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>作家</tag>
        <tag>公众号</tag>
        <tag>编程</tag>
        <tag>十年</tag>
      </tags>
  </entry>
</search>
