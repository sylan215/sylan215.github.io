<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[由 Python2 和 Python3 中 socket.inet_aton() 实现不同引发的血案]]></title>
    <url>%2Fpython-socket-inet-aton.html</url>
    <content type="text"><![CDATA[这几天在做一个功能实现的时候，需要把别人用 Python2.6 写好的脚步转成 Python3.4 实现，大部分地方转化都没啥问题，但是在 socket.inet_aton() 转化的过程中出了点问题，花费我不少的精力去解决，先做个记录备忘，同时给后续需要的人做个提醒。 首先说一下，我在解决这个问题前期的思路有点问题，所以请关注最后的总结。 需求目的：把一个 ip 地址使用 socket.inet_aton() 转化后和一个字符串组合，然后算出 MD5。 下面是 Python2.6 的实现代码： 1234567891011#!python2# -*- coding: utf-8 -*-import socketimport hashlibif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' ip_md5 = hashlib.md5(socket.inet_aton(ip) + base_str).digest().encode('hex') print(ip_md5) 运行后的输出结果为： fc138bb4748a18f885cc321c2c6396e2 如果原封不动的使用 Python3.4 运行后，报错如下： 123456Traceback (most recent call last): File "socket34.py", line 25, in &lt;module&gt; test1() File "socket34.py", line 10, in test1 ip_md5 = hashlib.md5(socket.inet_aton(ip) + base_str).digest().encode('hex')TypeError: can't concat bytes to str 提示说的是，socket.inet_aton(ip) 的返回值是 bytes 类型，所以不能和 str 类型的 base_str 直接进行连接操作。 也就是说 Python2.6 和 python3.4 中对于 socket.inet_aton(ip) 的实现是有差异的，查官方文档吧。 python2.6文档说明： socket.inet_aton(ip_string)Convert an IPv4 address from dotted-quad string format (for example, ‘123.45.67.89’) to 32-bit packed binary format, as a bytes object four characters in length. python3.4 文档说明： socket.inet_aton(ip_string)Convert an IPv4 address from dotted-quad string format (for example, ‘123.45.67.89’) to 32-bit packed binary format, as a string four characters in length. 好吧，返回值类型不同，为了保证和原脚本逻辑一致，我就做个转化，把 bytes 主动转换为 str 类型再连接，修改后的代码如下： 123456789101112#!python3# -*- coding: utf-8 -*-import socketimport hashlibif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' str_md5 = socket.inet_aton(ip).decode('gbk') + base_str ip_md5 = hashlib.md5(str_md5).digest().encode('hex') print(ip_md5) 代码通过 decode 把 bytes 使用 gbk 的方式解码成 str，至于为什么用 gbk，是因为我对比了下，只有 gbk 编码方式解码后的输出才和 python2.6 中的 str 返回值结果一致。 行，赶紧运行一把试试看。。。还是报错了，这次的报错内容变了： 123456Traceback (most recent call last): File "socket34.py", line 34, in &lt;module&gt; test1() File "socket34.py", line 12, in test1 ip_md5 = hashlib.md5(str_md5).digest().encode('hex')TypeError: Unicode-objects must be encoded before hashing 看起来 hashlib.md5() 在 Python2.6 和 Python3.4 中的实现也有差异，继续看文档。 python2.6文档说明： You can now feed this object with arbitrary strings using the update() method. python3.4 文档说明： You can now feed this object with bytes-like objects (normally bytes) using the update() method. 依然是编码格式的问题，Python2.6 中参数传入的是 str，但是 Python3.4 中参数需要传入 bytes，那就继续转码吧。 再次转码后的代码如下： 123456789101112#!python3# -*- coding: utf-8 -*-import socketimport hashlibif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' str_md5 = socket.inet_aton(ip).decode('gbk') + base_str ip_md5 = hashlib.md5(str_md5.encode('gbk')).digest().encode('hex') print(ip_md5) 运行后再次报错： 123456Traceback (most recent call last): File "socket34.py", line 33, in &lt;module&gt; test1() File "socket34.py", line 11, in test1 ip_md5 = hashlib.md5(str_md5.encode('gbk')).digest().encode('hex')AttributeError: 'bytes' object has no attribute 'encode' 好吧，继续看文档。 python2.6文档说明： hash.digest()Return the digest of the strings passed to the update() method so far. This is a string of digest_size bytes which may contain non-ASCII characters, including null bytes. python3.4 文档说明： hash.digest()Return the digest of the data passed to the update() method so far. This is a bytes object of size digest_size which may contain bytes in the whole range from 0 to 255. 这次更严重，encode() 直接用不了，换方法吧，更新后的代码如下： 12345678910111213#!python3# -*- coding: utf-8 -*-import socketimport hashlibimport binasciiif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' str_md5 = socket.inet_aton(ip).decode('gbk') + base_str ip_md5 = binascii.hexlify(hashlib.md5(str_md5.encode('gbk')).digest()).decode() print(ip_md5) 运行后的输出结果： fc138bb4748a18f885cc321c2c6396e2 终于得到了最终结果，激动，不过再回头一看，如果知道这几个函数的使用方式的话，就不需要 decode() 然后又 encode()，比如稍微优化后的代码如下： 12345678910111213#!python3# -*- coding: utf-8 -*-import socketimport hashlibimport binasciiif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' str_md5 = socket.inet_aton(ip) + base_str.encode() ip_md5 = binascii.hexlify(hashlib.md5(str_md5).digest()).decode() print(ip_md5) 总结： Python3 新增了 bytes 类型，对于 bytes 的转换逻辑要特别清楚，这地方涉及了编码类型，要特别关注； 在使用一些函数前，一定要搞清楚这个函数的具体实现，必须清楚的知道使用了这个函数是什么效果，而不仅仅是看到暂时的效果，或者经验主义的去调用(上面例子的最后一步，其实我一开始不是用的 binascii，而是用的现成的 md5 转换函数，导致 encode() 成了 utf-8 格式，而浪费了不少时间去定位)； 解决问题过程中，思路一定要清晰，不能靠猜，越猜越错； 先弄明白问题的根本原因，直接从根源上去解决，比一步步的就错解错，效果更好。]]></content>
      <categories>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>编码</tag>
        <tag>decode</tag>
        <tag>encode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 代码优化实践]]></title>
    <url>%2Fpython-youhua.html</url>
    <content type="text"><![CDATA[最近在用 Python 写一个一键替换文件的脚本文件，大概的功能是，向程序传递一个本地或 SFTP 目录的参数，程序可以把指定目录所有文件替换到特定应用程序的对应目录。程序提供了如下 2 种命令行调用： Usage: demo.py [sourcedir]Usage: demo.py [sourcedir] bydir 第一种调用的实际操作是：读取特定应用程序目录所有文件，并获取全路径作为一个集合，再把参数文件夹中文件按文件名与集合中文件进行匹配，如果匹配上则执行替换操作。 第二种调用的实际操作是：按参数文件夹的目录存放的路径，完整替换到应用程序的对应目录。 下面是最初的代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#执行本地文件替换的具体操作def ReplaceLocalFiles(filepath, context, filecontext, softpath, bydir): if (":" not in filepath) or (not os.path.isdir(filepath)): printandwritelog(u"目标路径有误，请确认是目录后再重试") return "error" fileList = os.walk(filepath) for root, dirs, files in fileList: for file in files: if bydir:#如果按目录进行替换的话走下面这个逻辑分支 filefullpath = os.path.join(root, file) targetfullpath = filefullpath.replace(filepath, softpath) shutil.copy2(filefullpath, targetfullpath) printandwritelog(u"文件 %s 拷贝到 %s 成功" % (filefullpath, targetfullpath)) else:#如果自行查找文件路径进行替换的话先走下这个逻辑分支 filecounts = checkcount(file, filecontext) if (0 == filecounts): printandwritelog(u"没有找到文件%s的路径，请使用指定路径方式进行替换" % file) continue elif (1 &lt; filecounts): printandwritelog(u"文件 %s 有 %s 个路径，请使用指定路径方式进行替换" % (file , filecounts)) continue elif (1 == filecounts): for line in context.split("\n"): filename = line.split("\\")[-1] if file == filename: os.rename(line , line + str(random.randint(0, 100))) shutil.copy2(os.path.join(root, file), line) printandwritelog(u"文件 %s 拷贝到 %s 成功" % (os.path.join(root, file), line)) else: printandwritelog(u"替换文件个数有误%s" % file)#判断如果是本地文件则直接调用替换函数，如果是网络路径，则先下载文件再替换def RelpaceFiles(filepath, context, filecontext, softpath, bydir): if ":" in filepath: printandwritelog(u"提供的本地路径，走本地路径文件替换流程") ReplaceLocalFiles(filepath, context, filecontext, softpath, bydir) else: printandwritelog(u"提供的FTP路径，先下载文件到本地后再执行替换流程") sourceFileDir = cur_file_dir() + r"\testdir" if os.path.isdir(sourceFileDir): shutil.rmtree(sourceFileDir) obj = netutilex.SFTP("192.168.1.100", "test", "testpwd") obj.syncSftpDir(filepath, sourceFileDir) obj.close() ReplaceLocalFiles(sourceFileDir, context, filecontext, softpath, bydir)#先处理替换前的前置操作，环境准备好之后执行替换操作 def ReplaceAllFiles(filepath, bydir): softpath = checkinst() if ("notinst" == softpath): printandwritelog(u"没有检测到卫士安装目录，请确认后重试") return "error" else: context, filecontext = getallfiles(softpath) RelpaceFiles(filepath, context, filecontext, softpath, bydir) 先简单说明下各函数的功能： ReplaceLocalFiles：主要功能函数，实现具体的替换操作；RelpaceFiles：根据传入参数判断是否是网络路径，如果是则先把文件下载到本地，然后调用ReplaceLocalFiles执行替换操作；ReplaceAllFiles：做了一些环境准备的事情，然后调用实际的功能函数RelpaceFiles进行干活；printandwritelog：记录日志并输出；checkinst：检查目标程序是否安装，如果安装则返回安装路径；getallfiles：获取目标应用程序的文件全路径集合；checkcount：获取指定文件名在目标应用程序文件集合中出现的次数netutilex：一个独立的操作SFTP的库文件。 从目前的代码中能发现至少有 2 个地方可以优化： 函数之间需要传递的参数太多了，可以看看是否全部必要，考虑下如何精简； 部分业务逻辑太细化，有重复的代码实现，导致实现看起来比较臃肿。 对于第 1 点，优化的思路是：对于非所有函数都必须调用的参数，尽可能的固化到实际使用的函数中，避免各函数仅仅做了传递员的工作。 对于第 2 点，优化的思路是：合并同类项，对于重复代码的部分，尽可能提取到共用逻辑中实现。 下面是优化后的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#执行本地文件替换的具体操作 def ReplaceLocalFiles(filepath, bydir): if (":" not in filepath) or (not os.path.isdir(filepath)): printandwritelog(u"目标路径有误，请确认是合法目录后重试") return "error" softpath = checkinst() if ("notinst" == softpath): printandwritelog(u"没有获取到目标软件安装目录，请确认后重试") return "error" context, filecontext = getallfiles(softpath) fileList = os.walk(filepath) for root, dirs, files in fileList: for file in files: filefullpath = os.path.join(root, file) targetfullpath = filefullpath.replace(filepath, softpath) if not bydir:#如果自行查找文件路径进行替换的话先走下这个逻辑分支 filecounts = checkcount(file, filecontext) if (0 == filecounts): printandwritelog(u"没有找到文件%s的路径，请使用指定路径方式进行替换" % file) continue elif (1 &lt; filecounts): printandwritelog(u"文件 %s 有 %s 个路径，请使用指定路径方式进行替换" % (file , filecounts)) continue elif (1 == filecounts): for line in context.split("\n"): filename = line.split("\\")[-1] if file == filename: targetfullpath = line else: printandwritelog(u"替换文件个数有误%s" % file) if os.path.isfile(targetfullpath): randomend = random.randint(0, 100) os.rename(targetfullpath , targetfullpath + str(randomend)) shutil.copy2(filefullpath, targetfullpath) printandwritelog(u"文件 %s 拷贝到 %s 成功" % (filefullpath, targetfullpath))#先处理替换前的前置操作，环境准备好之后执行替换操作 def ReplaceAllFiles(filepath, bydir): sourceFileDir = filepath if ":" in filepath: printandwritelog(u"提供的本地路径，走本地路径文件替换流程") else: printandwritelog(u"提供的FTP路径，先下载文件到本地后再执行替换流程") sourceFileDir = cur_file_dir() + r"\testdir" if os.path.isdir(sourceFileDir): shutil.rmtree(sourceFileDir) obj = netutilex.SFTP("192.168.1.100", "test", "testpwd") obj.syncSftpDir(filepath, sourceFileDir) obj.close() ReplaceLocalFiles(sourceFileDir, bydir) 具体的优化操作有： 把函数 checkinst 和 getallfiles 的调用实现放到了其返回值使用者 ReplaceLocalFiles 的函数体内，减少了 2 个参数的多次传递；把函数 ReplaceLocalFiles 中具体的 copy2 操作进行了提取，因为 bydir 和非 bydir 最终都会走到这个操作；把函数 ReplaceFiles 中对函数 ReplaceLocalFiles 的操作进行了提取，同时把函数 ReplaceAllFiles 和 ReplaceFiles 进行了合并。 优化后的结果看起来有没有清爽很多？]]></content>
      <categories>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>文件</tag>
        <tag>文件夹</tag>
        <tag>遍历</tag>
        <tag>SFTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何优雅的使用 Python 实现文件递归遍历]]></title>
    <url>%2Fpython-wenjianbianli.html</url>
    <content type="text"><![CDATA[今天有个脚本需要遍历获取某指定文件夹下面的所有文件，我记得很早前也实现过文件遍历和目录遍历的功能，于是找来看一看，嘿，不看不知道，看了吓一跳，原来之前我竟然用了这么搓的实现。 先发出来看看： 123456789101112131415161718#遍历获取指定文件夹下面所有文件def getallfiles(dir): if os.path.isdir(dir): filelist = os.listdir(dir) for ret in filelist: filename = dir + "\\" + ret if os.path.isfile(filename): print filename#遍历获取所有子文件夹下面所有文件def getalldirfiles(dir, basedir): if os.path.isdir(dir): getallfiles(dir) dirlist = os.listdir(dir) for dirret in dirlist: fullname = dir + "\\" + dirret if os.path.isdir(fullname): getalldirfiles(fullname, basedir) 我是用了 2 个函数，并且每个函数都用了一次 listdir，只是一次用来过滤文件，一次用来过滤文件夹，如果只是从功能实现上看，一点问题没有，但是这…太不优雅了吧。 开始着手优化，方案一： 123456789101112#使用listdir循环遍历def getallfiles(dir): if not os.path.isdir(dir): print dir return dirlist = os.listdir(dir) for dirret in dirlist: fullname = dir + "\\" + dirret if os.path.isdir(fullname): getallfiles(fullname) else: print fullname 从上图可以看到，我把两个函数合并成了一个，只调用了一次 listdir，把文件和文件夹用 if~else~ 进行了分支处理，当然，自我调用的循环还是存在。 有木有更好的方式呢？网上一搜一大把，原来有一个现成的 os.walk() 函数可以用来处理文件(夹)的遍历，这样优化下就更简单了。 方案二： 123456789#使用listdir循环遍历def getallfilesofwalk(dir): if not os.path.isdir(dir): print dir return dirlist = os.walk(dir) for root, dirs, files in dirlist: for file in files: print os.path.join(root, file) 只是从代码实现上看，方案二是最优雅简洁的了，但是再翻看 os.walk() 实现的源码就会发现，其实它内部还是调用的 listdir 完成具体的功能实现，只是它对输出结果做了下额外的处理而已。 附上os.walk()的源码： 1234567891011121314151617181920212223242526272829303132from os.path import join, isdir, islink# We may not have read permission for top, in which case we can't# get a list of the files the directory contains. os.path.walk# always suppressed the exception then, rather than blow up for a# minor reason when (say) a thousand readable directories are still# left to visit. That logic is copied here.try: # Note that listdir and error are globals in this module due # to earlier import-*. names = listdir(top)except error, err: if onerror is not None: onerror(err) returndirs, nondirs = [], []for name in names: if isdir(join(top, name)): dirs.append(name) else: nondirs.append(name)if topdown: yield top, dirs, nondirsfor name in dirs: path = join(top, name) if followlinks or not islink(path): for x in walk(path, topdown, onerror, followlinks): yield xif not topdown: yield top, dirs, nondirs 至于 listdir 和 walk 在输出时的不同点，主要就是 listdir 默认是按照文件和文件夹存放的字母顺序进行输出，而 walk 则是先输出顶级文件夹，然后是顶级文件，再输出第二级文件夹，以及第二级文件，以此类推，具体大家可以把上面脚本拷贝后自行验证。]]></content>
      <categories>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>文件</tag>
        <tag>递归</tag>
        <tag>文件夹</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 tinypng 进行批量压缩]]></title>
    <url>%2F20171109-compress-with-tinypng.html</url>
    <content type="text"><![CDATA[不管是博客还是产品中，都会涉及图片的使用，但是如果图片体检太大，会影响使用体验，所以网上有各种各样的支持图片压缩的网站，tinypng 是其中的佼佼者。 今天要介绍的就是如何通过 python 脚本实现一键压缩。 直接上脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- coding: utf-8 -*-"""脚本功能说明：使用 tinypng，一键批量压缩指定文件(夹)所有文件"""import osimport sysimport tinifytinify.key = "你自己申请的 key" # AppKeydef get_file_dir(file): """获取文件目录通用函数""" fullpath = os.path.abspath(os.path.realpath(file)) return os.path.dirname(fullpath)def check_suffix(file_path): """检查指定文件的后缀是否符合要求""" file_path_lower = file_path.lower() return (file_path_lower.endswith('.png') or file_path_lower.endswith('.jpg') or file_path_lower.endswith('.jpeg'))def compress_by_tinypng(input_file): """使用 tinypng 进行压缩，中文前面的 u 是为了兼容 py2.7""" if not check_suffix(input_file): print(u'只支持png\\jpg\\jepg格式文件：' + input_file) return file_name = os.path.basename(input_file) output_path = os.path.join(get_file_dir(sys.argv[0]), 'tinypng') output_file = os.path.join(output_path, file_name) print(output_file) if not os.path.isdir(output_path): os.makedirs(output_path) try: source = tinify.from_file(input_file) source.to_file(output_file) print(u'文件压缩成功：' + input_file) old_size = os.path.getsize(input_file) print(u'压缩前文件大小：%d 字节' % old_size) new_size = os.path.getsize(output_file) print(u'文件保存地址：%s' % output_file) print(u'压缩后文件大小：%d 字节' % new_size) print(u'压缩比： %d%%' % ((old_size - new_size) * 100 / old_size)) except tinify.errors.AccountError: print(u'Key 使用量已超，请更新 Key，并使用命令[Usage] %s [filepath] [key]运行' % os.path.basename(sys.argv[0]))def check_path(input_path): """如果输入的是文件则直接压缩，如果是文件夹则先遍历""" if os.path.isfile(input_path): compress_by_tinypng(input_path) elif os.path.isdir(input_path): dirlist = os.walk(input_path) for root, dirs, files in dirlist: for filename in files: compress_by_tinypng(os.path.join(root, filename)) else: print(u'目标文件(夹)不存在，请确认后重试。')if __name__ == '__main__': len_param = len(sys.argv) if len_param != 2 and len_param != 3: print('[Usage] %s [filepath]' % os.path.basename(sys.argv[0])) elif len_param == 3: tinify.key = sys.argv[2] check_path(sys.argv[1]) else: check_path(sys.argv[1]) 使用说明1. 请先安装 tinify 的依赖库：1python -m pip install tinify 2. 申请 tinify key到 https://tinypng.com/developers 申请自己的 key，每个 key 每个月可以压缩 500 个文件。 3. 执行脚本申请完 key 之后，更新到代码段中的：1tinify.key = "your key" # AppKey 然后带参数执行脚本即可。 带的第一个参数是必选的，可以是文件，也可以是文件夹。 第二个参数是可选的，自定义 key，如果输入了第三个参数，则优先使用自定义 key。 压缩后的文件，默认输出到当前脚本所在目录下的 tinypng 文件夹中，如果要输出到其他位置，可以自行修改脚本实现。 PS：已使用 Python2.7 和 Python3.4 亲测有效，其他 Python 版本如果有异常，请反馈。 更详细的说明请跳转到项目地址：https://github.com/sylan215/compress-with-tinypng，欢迎大家 star，并一起丰富这个脚本的功能。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>环境</tag>
        <tag>tinypng</tag>
        <tag>存储格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存不足导致 nginx 崩溃的原因分析]]></title>
    <url>%2F20171108-OOM-openfiles.html</url>
    <content type="text"><![CDATA[最近在 Centos7 上搭建 nginx 作为 web 服务器使用，但是使用过程中，nginx 总是莫名其妙的崩掉，使用命令 dmesg 检查错误信息如下： 12[6655217.659132] Out of memory: Kill process 11494 (lsof) score 10 or sacrifice child[6655217.659567] Killed process 11494 (lsof) total-vm:161160kB, anon-rss:42368kB, file-rss:0kB, shmem-rss:0kB 使用命令 cat /var/log/nginx/error.log 来查看 nginx 的错误日志包含如下信息: 122017/10/26 22:59:45 [crit] 13093#0: accept4() failed (23: Too many open files in system)2017/10/26 22:59:45 [crit] 13092#0: accept4() failed (23: Too many open files in system) 经过高人指点，是系统配置设置没法满足当前的使用量，准确点说是系统的 open files (打开文件数目)配置的太低了。 使用命令 ulimit -a 看一下当前置： 12345678910111213141516core file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 15089max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 1024pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 15089virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 可以看到 open files 值，只有 1024，下面我们就详细说一下如何在 Centos 系统级别提高打开文件数目(open files)的限制。 详细步骤： 使用命令 sudo bash 切换到 root 账户； 使用 vi/vim 编辑 /etc/sysctl.conf 增加一行 fs.file-max = 100000，下面是修改后的结果： 12345678910[root@test /]# cat /etc/sysctl.conf# System default settings live in /usr/lib/sysctl.d/00-system.conf.# To override those settings, enter new settings here, or in an /etc/sysctl.d/&lt;name&gt;.conf file## For more information, see sysctl.conf(5) and sysctl.d(5).net.ipv6.conf.all.disable_ipv6 = 1net.ipv6.conf.default.disable_ipv6 = 1net.ipv4.tcp_challenge_ack_limit = 999999999kernel.kptr_restrict = 1fs.file-max = 100000 使用 vi/vim 编辑 /etc/security/limits.conf，并在末尾增加如下语句，用来增加所有用户的软硬句柄和文件打开数目限制： 12* soft nofile 100000* hard nofile 300000 下面是修改后的结果： 12345[root@test /]# cat /etc/security/limits.conf# 省略的内容# End of file* soft nofile 100000* hard nofile 300000 执行命令 sysctl -p 让修改生效； 通过命令 whereis nginx 查看 nginx 配置文件所在位置： 12[root@test /]# whereis nginxnginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man3/nginx.3pm.gz /usr/share/man/man8/nginx.8.gz 使用 vi/vim 编辑 /etc/nginx/nginx.conf 来在 nginx 级别上提高打开的文件句柄限制： 12345678[root@test /]# cat /etc/nginx/nginx.conf# 省略的内容user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;worker_rlimit_nofile 300000;# 省略的内容 使用 reboot 命令重启系统后，我们分别使用 ulimit -Hn、ulimit -Sn 和 ulimit -a 来查看修改后的效果： 123456789101112131415161718192021[root@test /]# ulimit -Hn300000[root@test /]# ulimit -Sn100000[root@test /]# ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 15089max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 100000pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 15089virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 上述示例的设置值均是对公共服务器的配置，具体数据请根据系统实际需要进行设定； 如果上述方法仍然没有解决问题，可以考虑： 1.使用服务的方式启动 nginx 试试；2.加配置内存。 参考文章：http://www.cnblogs.com/sxlfybb/archive/2011/09/15/2177983.html]]></content>
      <categories>
        <category>环境搭建</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ulimit</tag>
        <tag>Ubuntu</tag>
        <tag>内存不足</tag>
        <tag>open files</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 Git 实现版本回退]]></title>
    <url>%2F20171107-git-revert-reset.html</url>
    <content type="text"><![CDATA[使用 Git 进行版本管理时，肯定不只做提交，有时候也会需要回退修改，并且在回退的基础上进行重新提交，这时候有几个常用的命令就需要用到了，下面分别做介绍。 查看提交日志首先，我们查看当前提交记录的命令： 123456789101112$ git logcommit bfee9d6618bc1deae52ac4a7942b96990bbfe661 (HEAD -&gt; master, origin/master, origin/HEAD)Author: sylan215 &lt;sylan215@sylan215.com&gt;Date: Thu Oct 19 15:19:30 2017 +0800 dddcommit fbb28efb4e156031704abbf015b12c8ef16031c8Author: sylan215 &lt;sylan215@sylan215.com&gt;Date: Thu Oct 19 15:15:26 2017 +0800 revert 如果 log 太多，可以加上参数 --pretty=oneline 使用： 123456$ git log --pretty=onelinebfee9d6618bc1deae52ac4a7942b96990bbfe661 (HEAD -&gt; master, origin/master, origin/HEAD) dddfbb28efb4e156031704abbf015b12c8ef16031c8 revertca0e36b485a3de75e6e11064aecc22ce100652dd new line45dcf1bc797a773ca3dee07fc795ef986d10c346 t5e29356aa7aea31e7e6bce302abbc2259324d806 test 查看命令执行记录查看本机命令的执行记录： 123456789$ git reflogbfee9d6 (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@&#123;0&#125;: reset: moving to bfee9d6618bc1deae52ac4a7942b96990bbfe661bfee9d6 (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@&#123;1&#125;: commit: dddfbb28ef HEAD@&#123;2&#125;: reset: moving to fbb28efb4e156031704abbf015b12c8ef16031c8fbb28ef HEAD@&#123;3&#125;: reset: moving to fbb28efb4e156031704abbf015b12c8ef16031c8fbb28ef HEAD@&#123;4&#125;: commit: revertca0e36b HEAD@&#123;5&#125;: reset: moving to ca0e36b485a3de75e6e11064aecc22ce100652ddca0e36b HEAD@&#123;6&#125;: commit: new line45dcf1b HEAD@&#123;7&#125;: reset: moving to 45dcf1 使用 reset 进行回退我们可以通过上述两种方式查看之前的记录，并找到要回退的版本，回退的版本有两种表示方法，一个是 commit id，就是那一串字符，一种是相对 HEAD 的序号，看下命令： 12345$ git reset --hard HEAD^^HEAD is now at ca0e36b new line$ git reset --har bfee9dHEAD is now at bfee9d6 ddd 我们先使用 HEAD^^ 回退了两个版本，然后又使用 bfee9d 这个 commit id 回到了最新版本，注意 HEAD 方式只能回退到旧版本，没法往新版本前进， commit id 的方式可以回退到任意有效 id 的版本，至于怎么查看版本对应的 id 请看最开始介绍的 git log 和 git reflog 命令。 这个命令我们还可变相达成丢弃目前所有修改的效果，直接运行 git reset --hard HEAD 就行。 回退版本后，我们重新进行修改，并提交，会发现有如下报错： 1234567891011121314$ git add .$ git commit -am &quot;test reset&quot;[master 88b1dc8] test reset 1 file changed, 1 insertion(+), 1 deletion(-)$ git pushTo 192.168.252.130:/srv/myfiles.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to &apos;git@192.168.252.130:/srv/myfiles.git&apos;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 解决方法是使用命令 git push -f 解决： 1234567$ git push -fCounting objects: 3, done.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 286 bytes | 286.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To 192.168.252.130:/srv/myfiles.git + bfee9d6...88b1dc8 master -&gt; master (forced update) 注意：git push -f 是强制提交的意思，如果和 reset 结合使用，就会把最新版本到 reset 到的版本之间的所有 commit 全部抹掉了，这在多人协作时，要特别注意。 具体我们通过命令后 git long --pretty=oneline 看得更直观： 12345$ git log --pretty=oneline88b1dc8cb7228f7d1fe14d510a62201a9d584118 (HEAD -&gt; master, origin/master, origin/HEAD) test resetca0e36b485a3de75e6e11064aecc22ce100652dd new line45dcf1bc797a773ca3dee07fc795ef986d10c346 t5e29356aa7aea31e7e6bce302abbc2259324d806 test 和最上面那一次的输出对比，commit id ca0e36b485a3de75e6e11064aecc22ce100652dd 之后的两个提交 id 都被回退了(fbb28efb4e156031704abbf015b12c8ef16031c8 和 bfee9d6618bc1deae52ac4a7942b96990bbfe661)。 另一种温柔的回退方式使用 reset 是直接抹杀掉 commit 的方式，另外还有一种真正的「回退」命令，就是 revert，它的效果时，在当前版本基础上，删掉要回退版本的修改内容后新建一次提交。我们看看效果： 123456789101112$ git log --pretty=oneline9eecd39b8e6a2109c3678c42dc034db2190840f6 (HEAD -&gt; master, origin/master, origin/HEAD) changee4f5e6920c22b748d765824e0be21015332fafa4 init$ git revert 9eec[master f7c9eb4] Revert &quot;change&quot; 1 file changed, 1 insertion(+), 2 deletions(-)$ git log --pretty=onelinef7c9eb4120d368915a6e5491bf85dc5cd87a424f (HEAD -&gt; master) Revert &quot;change&quot;9eecd39b8e6a2109c3678c42dc034db2190840f6 (origin/master, origin/HEAD) changee4f5e6920c22b748d765824e0be21015332fafa4 init 我们在最新版本的基础上，把最后一次提交的修改给回退了，同时用回退后版本生成了一次提交，并生成了新的 commit id，这样所有的操作 log 均得到了正确的保留。 注意：命令 revert 是指回退指定版本的修改内容，而不是指指定版本到当前版本的所有内容，所以如果给定的 commit id 不是当前版本的最新 commit id，那么就会报错： 12345678910111213141516171819202122232425262728$ git log --pretty=oneline45734f3dc12f45e78504bd0fb52ba334c0ae2c9f (HEAD -&gt; master, origin/master, origin/HEAD) test7c82b777a40dfb24fc1bba404be0daa3b3923a95 test revertf7c9eb4120d368915a6e5491bf85dc5cd87a424f Revert &quot;change&quot;9eecd39b8e6a2109c3678c42dc034db2190840f6 changee4f5e6920c22b748d765824e0be21015332fafa4 init$ git revert 7c82berror: could not revert 7c82b77... test reverthint: after resolving the conflicts, mark the corrected pathshint: with &apos;git add &lt;paths&gt;&apos; or &apos;git rm &lt;paths&gt;&apos;hint: and commit the result with &apos;git commit&apos;$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.You are currently reverting commit 7c82b77. (fix conflicts and run &quot;git revert --continue&quot;) (use &quot;git revert --abort&quot; to cancel the revert operation)Unmerged paths: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: test2.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 如果上图，我们跳过了 45734 的修改，想只回退 7c82b 的修改，这时候就提示冲突了，这时候要么手工修改冲突，要么取消 revert 后，一次指定多个 revert id 来实现，下面是一次使用多个 revert id 进行实现： 1234567891011121314151617181920212223$ git revert --abort$ git log --pretty=oneline45734f3dc12f45e78504bd0fb52ba334c0ae2c9f (HEAD -&gt; master, origin/master, origin/HEAD) test7c82b777a40dfb24fc1bba404be0daa3b3923a95 test revertf7c9eb4120d368915a6e5491bf85dc5cd87a424f Revert &quot;change&quot;9eecd39b8e6a2109c3678c42dc034db2190840f6 changee4f5e6920c22b748d765824e0be21015332fafa4 init$ git revert 45734 7c82b[master 8140eb0] Revert &quot;test&quot; 1 file changed, 1 insertion(+), 3 deletions(-)[master 191816d] Revert &quot;test revert&quot; 1 file changed, 1 insertion(+), 2 deletions(-)$ git log --pretty=oneline191816d84c02a4ba591d3739739ddd0df114d7f1 (HEAD -&gt; master) Revert &quot;test revert&quot;8140eb0f69493f1a6306b0e92822f07c049a7a50 Revert &quot;test&quot;45734f3dc12f45e78504bd0fb52ba334c0ae2c9f (origin/master, origin/HEAD) test7c82b777a40dfb24fc1bba404be0daa3b3923a95 test revertf7c9eb4120d368915a6e5491bf85dc5cd87a424f Revert &quot;change&quot;9eecd39b8e6a2109c3678c42dc034db2190840f6 changee4f5e6920c22b748d765824e0be21015332fafa4 init 这时候如果我们查看文件，会发现 45734 和 7c82b 的内容都被回退了，并新生成了两次的 commit(每个 commit id 的回退会单独生成一条记录)。 特别说明一下，为了保证 revert 的效果，建议每次提交修改的时候，尽量减少非耦合文件的一起提交，分批提交可以更利于以后的 revert。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>revert</tag>
        <tag>reset</tag>
        <tag>回退</tag>
        <tag>回滚</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 VM 虚拟机端口映射实现数据转发]]></title>
    <url>%2F20171104-vm-nat.html</url>
    <content type="text"><![CDATA[随着虚拟化技术的应用，很多环境配置都是在虚拟机中进行的，比如前几天我搭建的 Git 服务器，就是在一个物理机的虚拟机上搭建的，一方面可以做环境隔离，另一方面也方便管理，但是这样会带来另一个新的问题：网络访问。 我的多个物理机的网段是相通的，但是虚拟机和其所在物理机使用的是 NAT 模式，所以虚拟机和非其所在的物理机没法直接连通，可以使用如下命令确认下： 12&gt; telnet 192.168.252.129 22正在连接192.168.252.129...无法打开到主机的连接。 在端口 22: 连接失败 下面要介绍的就是如果如何通过 VMware 自身提供的端口转发机制来实现通讯(多谢珂仔的技术支持)。 环境物理机：10.13.11.12物理机：10.13.11.13虚拟机 IP：搭建在 10.13.11.12 上，IP 为 192.168.252.129虚拟机：VMware 14 开始设置查看虚拟机 IP 需要先查看当前的虚拟机 IP，因为后面映射的时候，需要填写 IP 和端口信息： 设置入口 通过 菜单 -&gt; 编辑 -&gt; 虚拟网络编辑器 入口打开设置界面： 提权 我当前使用的是 Windows 7 系统，如果当前用户不是系统的那种 administrator 并且系统开启了 UAC 的话，需要先进行操作提权，才能进行设置，提权操作如下： NAT 设置入口 提权成功后，需要选择当前虚拟机对应的网络，然后点击「NAT 设置」进入详细设置界面： 添加端口转发 在打开的「NAT 设置」界面，点击「添加」来添加对应的转发端口信息： 设置映射 在弹出的对话框，填入物理机的映射端口，注意不能填已经被占用的端口，然后填写虚拟机的 IP 和要转发的端口，比如我要转发的是 git 默认的 ssh 端口，所以填的 22： 确认连接 填写完成后，一路确定下去，直到完成，然后可以在另一台物理机上验证连通性了： 1&gt; telnet 10.13.11.12 10001 确认是可以访问的，这时候在 ssh 配置文件 config 中配置了上述配置后，使用 git 也确认是可以连接到虚拟机的 git 服务器的。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>虚拟机</tag>
        <tag>映射</tag>
        <tag>访问</tag>
        <tag>转发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用七牛接口实现图片和文件一键上传]]></title>
    <url>%2Fupload-to-qiniu.html</url>
    <content type="text"><![CDATA[本文主要介绍使用七牛提供的接口把七牛云作为图床，用 Python 实现图片上传和文件上传的脚本实现，可以支持按文件夹批量上传。 搭建过网站的同学，一定都涉及到图片上传和文件上传的问题，最近为了弄图片资源接触了一下云存储，还挺挺好用。 之前如果我们把图片资源存储到本机服务器，那就每次写文章的时候都需要准备一堆的图片，并且要上传到对应的相对目录上去，如果用了云存储(不限七牛)，好处就是需要的资源直接上传，然后生成一个链接来使用就行了，Markdown 语法对链接的支持也很好，恩，可以搞一下。 不过，又有了新问题，就是是用云存储，得先经过登录-&gt;打开对象存储-&gt;打开内容管理-&gt;上传，然后填入上传后的相对目录，并手动选择本地文件，是不是很麻烦？ 所以本次是提供了一个一键上传资源的脚本(仅针对七牛云)，实现的效果就是，输入项目目录和文件本地地址后，自动上传所有文件到云端，并生成可使用 URL。 来，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-import osimport sysfrom qiniu import Auth, put_fileif 3 != len(sys.argv): print('[Usage] %s [dir_set] [filepath]' % os.path.basename(sys.argv[0])) sys.exit(0)else: # dir_set 的格式为 image/upload-qiniu/ ，注意末尾带反斜杠/ dir_set = sys.argv[1] file_path = sys.argv[2]# 个人中心-&gt;密匙管理-&gt;AKaccess_key = '你的AccessKey'# 个人中心-&gt;密匙管理-&gt;SKsecret_key = '你的SecretKey'# 七牛空间名bucket_name = '你的存储空间名'qiniu_auth = Auth(access_key, secret_key)def upload_qiniu(input_path): #upload single file to qiniu filename = os.path.basename(input_path) key = '%s%s' % (dir_set, filename) token = qiniu_auth.upload_token(bucket_name, key) ret, info = put_file(token, key, input_path, check_crc=True) if ret and ret['key'] == key: print('%s done' % ('http://www.sylan215.com/' + dir_set + filename)) else: print('%s error' % ('http://www.sylan215.com/' + dir_set + filename))def upload_all_files(input_path): if os.path.isfile(input_path): upload_qiniu(input_path) elif os.path.isdir(input_path): dirlist = os.walk(input_path) for root, dirs, files in dirlist: for filename in files: upload_qiniu(os.path.join(root, filename)) else: print('Please input the exists file path!')if __name__ == "__main__": upload_all_files(file_path) 使用说明1. 请先安装 qiniu 的依赖库：1python -m pip install qiniu 2. 修改绑定域名修改代码中的 http://www.sylan215.com 为自己在七牛云存储绑定的域名 3. 带两个参数执行脚本第一个参数是上传后的目录，第二个参数是文件在本地的地址，支持文件夹。 其中第一个参数的目录格式为：image/test/。 比如如下的命令: 1upload_to_qiniu.py image/test/ d:\test.png 运行后，上传后的文件地址就类似：http://www.sylan215.com/image/test/test.png PS：已使用 Python2.7 和 Python3.4 亲测有效，其他 Python 版本如果有异常，请反馈。 更详细的说明请跳转到项目地址：https://github.com/sylan215/upload-to-qiniu，欢迎大家 star，并一起丰富这个脚本的功能。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>七牛图片上传</tag>
        <tag>七牛文件上传</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next 主题下点击后出现红心效果]]></title>
    <url>%2Fhexo-next-hongxin.html</url>
    <content type="text"><![CDATA[本文主要介绍通过 javascript 脚本实现鼠标点击后，有小红心冒出的特效，下面是详细操作步骤。 在 hexo\themes\next\source\js\src\ 目录下新增文件 love.js，文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546!function(e, t, a) &#123; function n() &#123; c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = "left:" + d[e].x + "px;top:" + d[e].y + "px;opacity:" + d[e].alpha + ";transform:scale(" + d[e].scale + "," + d[e].scale + ") rotate(45deg);background:" + d[e].color + ";z-index:99999"); requestAnimationFrame(r) &#125; function o() &#123; var t = "function" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function(e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement("div"); a.className = "heart", d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement("style"); a.type = "text/css"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName("head")[0].appendChild(a) &#125; function s() &#123; return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")" &#125; var d = []; e.requestAnimationFrame = function() &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n()&#125;(window, document); 然后在文件 hexo\themes\next\layout\_layout.swing 底部的 &lt;/body&gt; 标签上一行增加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 好了，执行命令 hexo s --debug 看看效果吧。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>鼠标点击</tag>
        <tag>红心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个版本的 Python 在使用中的灵活切换]]></title>
    <url>%2Fpython-config-build.html</url>
    <content type="text"><![CDATA[今天我们来说说在 windows 系统上如果有多版本的 python 并存时，如何优雅的进行灵活切换。 虽然 Python3 已经出来很久了，虽然 Python2 即将成为历史了，但是因为历史原因，依然有很多公司的老项目继续在使用着 Python2 版本(切换成本太高)，所以大多数开发者机器上 Python2 和 Python3 都是并存的，本文主要说明这种情况下如何便捷的在 Python2 和 Python3 之间进行切换。 先说明下，本次我们不介绍 virtualenv，也不介绍 pipenv，因为这两个都是为了大型的 Python 工程做准备的，之后会单独文字进行说明。 本次是不借助外部工具，来实现快捷切换。其实也可以说是利用系统环境变量的逻辑来实现目的。 本次环境以 Windows 为例： 系统： Windows 7 x64Python 版本：Python3.4 和 Python 2.7 安装首先安装好 Python3.4 和 Python2.7，安装包可以在这个地方进行下载：点击跳转。 设置环境变量然后分别把对应版本的安装路径加入到系统环境变量中去： 新起一个 cmd 窗口验证下添加后的效果： 123C:\Users&gt;pathPATH=C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files\Git\cmd;C:\Python34;C:\Python27; 这时候我们直接在 cmd 输入 python，已经可以被识别了，但是识别的总是路径在环境变量中排前面的那个版本的 Python，比如目前从上图看 Python3.4 是排前面的，实际验证下看看： 12345C:\Users&gt;pythonPython 3.4.4 (v3.4.4:737efcadf5a6, Dec 20 2015, 20:20:57) [MSC v.1600 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 重命名主程序然后我们分别把两个版本的 Python 主程序 exe 改下名，3.4 版本的改名为 python34.exe，2.7 版本的改名为 python27.exe： 再分别运行 python34 和 python27 试试： 1234567891011C:\Users&gt;python34Python 3.4.4 (v3.4.4:737efcadf5a6, Dec 20 2015, 20:20:57) [MSC v.1600 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;C:\Users&gt;python27Python 2.7.14 (v2.7.14:84471935ed, Sep 16 2017, 20:19:30) [MSC v.1500 32 bit (Intel)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 从上图可以看出，我们已经可以实现分别运行指定版本的效果了，如果执行脚本的话直接 python34 test.py 或者 python27 test.py 就行了。 但是每次执行脚本都加前缀是不是很累，如果有一个版本是我们常用的话，也可以通过修改文件后缀关联程序来实现默认关联，再需要特殊版本的时候再加上前缀就行，不过保险起见，还是一直带着吧。 补充说明补充说明下，其实网上也有网友提供了其他两种方法： 使用 Python 自带的 py -2 和 py -3 命令；另一种和我上面说的类似，但是只重命名了其中一个版本的执行文件名； 如果机器只安装了两个版本的 Python，这几个方法确实是都可以解决的，但是因为我需要部分脚本支持 Windows XP (Python3.5 以后就不支持 XP 了)，所以安装了 Python2.7、Python3.4 和 Python3.6 共三个版本的 Python，这样的话就只能把全部主程序文件都重命名了，而且这样解决的问题更彻底，一劳永逸。 再补充说明下，如果要针对不同版本的 Python 调用 pip，命令后如下(请把 requests 换成自己需要的包名)： 123python27 -m pip install requestspython34 -m pip install requestspython36 -m pip install requests 这样安装的依赖库就是在各个版本之间相互独立的。 好了，赶紧动手试试吧。当然，如果您有更好的建议，欢迎留言讨论。]]></content>
      <categories>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>python多版本共存</tag>
        <tag>windows python多版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何删除 Launchpad 中的无用图标]]></title>
    <url>%2Frestore-launchpad.html</url>
    <content type="text"><![CDATA[最近在 Mac 上使用 Atom，发现 Atom 并不是安装上去的，下载后解压直接就是个 app 了，所以我手动给拖拽到 Launchpad 了。 今天突然发现有个新版本，所以重新下载了一个，双击运行后，发现两个并不是同一个来源，所以就把老的源文件给删掉了，但是老版本对应的 Launchpad 图标还在，搞不懂。 所以又手动拖了一遍新版本 Atom 到 Launchpad，这下可好，竟然有两个 Atom 图标了，尝试使用长按后点叉叉的方式给删掉，却发现这俩图标上面竟然没有叉叉，郁闷了，人肉到网上搜了几个方案都不是特别实用，终于找到一个亲测可用的赶紧记录备案。 步骤： 在 Docker -&gt; 系统偏好设置 中打开终端 终端中输入：defaults write com.apple.dock ResetLaunchPad -bool true 后回车 终端中输入：killall Dock 后回车 重新打开 Docker 查看效果，一切都被还原，赞 注意：这种方式会还原自己自定义的一切设置，比如图标分类等，请按需取用]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Launchpad</tag>
        <tag>恢复</tag>
        <tag>删除图标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心流]]></title>
    <url>%2Fheart-flow.html</url>
    <content type="text"><![CDATA[最近在看《驱动力》这本书，其中有提到「心流」这个词，只是从描述来说，有点太抽象，不过刚好最近感受了几次「心流」的感觉，所以记录一下。先说下概念，心流主要是指一种自动的、非刻意的、高度集中、全情投入并享受其中的的忘我精神状态。 我自己感受到的「心流」状态是最近在学习 python 编程，通过编写一些工作中需要用到的工具的过程。 这个过程中的带来的特殊感受有： 自己制定目标，自己规划目标，并自觉的持续达成；达成目标过程中的所有问题都有耐心并积极的寻求问题的解决办法；时间过得特别快，甚至愿意花费自己的休息时间来保证目标达成；持续的改进动力，且没有对回报的渴求，更加享受这个过程； 其中有三次典型的心流峰值，下面分别说明。 第一次是解决一个编码的问题。这是一个工具的需求，需求是使用字符串形式读取一个 PE 文件，然后暴力搜索其中的字符串。 同样的实现语句，在 Python2 中的输出是正确的，但是在 Python3 中的输出却不正确，检查发现和默认编码有关系，Python2 默认使用的 ascii，而 Python3 默认使用的是 utf-8，如果使用记事本打开的话，默认也是使用 ascii，所以和 Python2 的效果一样。 为了让实现效果一致，在 Python3 的实现中我显式设置 encoding 为 gbk 了： 1f = open(readFile, 'r', encoding='gbk') 结果就是这个语句报错了：1'gbk' codec can't decode byte 0x90 in position 2: illegal multibyte sequence 也就是这个错误导致我纠结了很久，花费了不少的时间，甚至有一段时间都搁置了，最终我把问题提交到了 stackoverflow，同时继续查资料，也就是提交问题后不久，就在 python 官方文档中找到了解决方案： 12345The errors parameter is the same as the parameter of the decode() method butsupports a few more possible handlers. As well as &apos;strict&apos;, &apos;ignore&apos;, and&apos;replace&apos; (which in this case inserts a question mark instead of the unencodable character), there is also &apos;xmlcharrefreplace&apos; (inserts an XML characterreference) and backslashreplace (inserts a \uNNNN escape sequence). 其实还是蛮讽刺的，因为基础没打牢，一个基本的函数实现却耗费了不少的时间，虽然解决问题后，那种兴奋的感觉还是蛮让人激动，不过最大的收获还是发现问题先看官方文档。 上述问题的详细描述可以 看 stackoverflow。 第二次是解决一个打包的问题。因为我的工具会分发给大家使用，但不是每个人的环境都安装了 Python3，或者即使安装了，相关的依赖库也不一定完备，所以我是使用 pyinstaller 进行了打包后再进行分发的，但是因为 pyinstaller 自身的 Bug，让我打包的 exe 总是没法自动提权，网上搜了下，很多人碰到这个问题，但是都没有很完整的解决方案，自己在尝试多次后，都有点要放弃了。 最后突然想起来自己使用的某些工具也是使用了类似的功能，所以问了下这些工具的打包流程，要了打包脚本看了下，突然了恍然大悟了，没有问题的这个是使用的 pyinstaller 提供的另外一个方式而已，只是会稍微麻烦点，需要单独准备资源文件，然后把资源文件进行嵌入，自己拿来改造优化一下，最终实现了预期效果。 这件事给的教训就是，很多问题，一定要站在前人的肩膀上去看问题，这样可以是事半功倍，当然，拿了别人的解决方案也不能仅仅是拿来主义，需要搞明白其中的原理，方便自己举一反三，或者优化改进。 另外，对于自己在过程中付出了努力、时间和精力的问题，最终解决的时候，还是十分令人激动的，我认为这就是「心流」的感觉。 第三次是解决一个父子窗口联动的问题。这次和第一个问题有点类似，就是有一个实现的效果，明明知道可以实现，但就是不知道怎么去写代码实现，或者说不知道方法怎么合理去利用。 我大概描述一下吧：我新建了一个窗口，是在主窗口上点击按钮后弹出的，现在我要在新窗口修改主窗口的内容，但是一直不知道怎么调用主窗口的控件。 和第一个问题类似，我也知道需要利用父类继承的逻辑来达到效果，但就是不知道怎么去写。 在尝试了多种实现方案，在网上看了所有能看到的资料后，最终还是把问题提交到了 stackoverflow，结局和第一个问题类似，在我提交了问题后不久，自己就又找到了问题的解决方案，仅仅是在自己之前的方法中多增加一个初始化字段： 1self.parent = parent 问题是简单的，道路是曲折的，问题解决了，心情是高兴的，留给自己更大的反思还是对于一些基础的巩固一定要加强，只有某一些理论知识丰富了，后面的实践才能更得心应手。 当然，本次主要想说明的是解决问题的兴奋感，不管问题大小，只要是自己觉得有价值的，那么问题带来的不是挫折、不是困难、不是灾难，是兴奋、激动和「心流」的感觉。 上述问题的详细描述可以 看 stackoverflow。 简单做下总结。 发现问题和解决问题的过程是最有意义的，有些问题解决后才发现原来只是某一点没有想到而已，但是在没有想到之前，这就是一个盲点，而解决这个盲点就是这个过程中最大的意义。 比如最后一个问题，其实我之前也尝试过用父类的方法进行传递和调用，但是方法不正确，导致结果也不正确，最后就尝试其他方法，最后却还是兜兜转转转回来了。 另外一点感触就是，基础知识太重要了，有些盲点仅仅是因为太注重实用过程，所以疏于基础的巩固，那么一些很基础的特性可能就不会被想到，那么导致的就是问题解决的复杂度提高了，比如第一个问题的 ignore 参数问题，理论来说，是个函数的基本参数而已，不应该因此耗费太多时间。 最后一点，「问题」不仅仅是「问题」而已，他是一个契机、一个场景、一个过程、一种经历，只有经历了「问题」，才能享受到解决问题的「心流」的感觉。 人生不也是如此？ Enjoy it!]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>驱动力</tag>
        <tag>python</tag>
        <tag>encoding</tag>
        <tag>问题</tag>
        <tag>心流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你在 Ubuntu 上搭建 Git 服务器]]></title>
    <url>%2Fgit-config-on-ubuntu.html</url>
    <content type="text"><![CDATA[最近在写一些脚本，为了保持连续性，就在家也抽空赶进度，所以碰到了代码同步的问题，目前想到的方法有三个： 使用云盘，这个拿来即用，但是因为云盘还存放了其他一些东西，总是实时同步不太妥当；使用 SVN，传统的代码托管工具，一直在用；使用 Git，最新的分布式代码托管工具，据说很强大。 最后决定使用 Git，主要是学习下最新的技术。下面是操作步骤，做记录的同时也给其他同学做个指引： 先说下环境： 服务端： Ubuntu 16.04 x64客户端： Windows7 x64 服务端配置先使用如下命令切到 root 权限进行操作： 1sudo bash 提示输入密码时，输入 root 密码即可。 登录成功后，开始安装 git，命令： 1apt-get install git 提示是否继续时，输入 y 后回车，安装流程继续，并直至安装完成。 接着开始安装 ssh，命令： 1apt-get install openssh-server openssh-client 同样在询问是否继续时，输入 y 后回车，安装会自动完成。 然后我们新建一个 git 专属用户，用户名也叫 git，命令： 1adduser git 新建成功后会提示设置用户密码，请设置一个自己能记住的密码后继续，后续的详细信息可以酌情填写。 下面开始新建 git 仓库，我们选定仓库存放目录为 /srv 下面，仓库名 myfiles.git，所以命令： 1git init --bare /srv/myfiles.git 因为当前用户是 root，为了让后面 git 专用账户能够操作仓库目录，我们需要把仓库目录授权给 git，命令： 1chown -R git:git /srv/myfiles.git/ 客户端操作首先需要下载 Windows 版本的 git，下载地址：点击下载 下载完成后点击安装，并根据提示点击「下一步」，直到安装完成。 在客户端创建一个工作目录，比如我的是 gitdir，在工作目录内右键并点击 「Git Bash Here」。 在弹出的命令后窗口 clone 仓库到本地： 12345678$ git clone git@192.168.252.128:/srv/myfiles.gitCloning into 'myfiles'...The authenticity of host '192.168.252.128 (192.168.252.128)' can't be established.ECDSA key fingerprint is SHA256:zqtjAg+FGfWrT3SCp1Qa2KqhE2UOy3PmudhhrTFlm7A.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.252.128' (ECDSA) to the list of known hosts.git@192.168.252.128's password:warning: You appear to have cloned an empty repository. 注意请把「192.168.252.128」换成自己的服务端 ip，并且在确认时输入的是「yes」，最后输入的是创建 git 用户时候的密码。 为了客户端进行后续的提交操作，我们还需要注明当前机器的用户信息，命令后如下： 12git config --global user.email "you@example.com"git config --global user.name "Your Name" 注册后，commit 的时候会使用这个注册信息来记录操作人信息，然后在使用 git log 时可以看到对应的信息，效果如下图： 123456$ git logcommit ae72bcc89ea8f5d9d3a44f0e00cf35e91a1afce8 (HEAD -&gt; master, origin/master)Author: sylan215 &lt;sylan215@sylan215.com&gt;Date: Wed Oct 18 18:37:41 2017 +0800 测试提交 至此，我们完成整个配置过程。 文件修改并同步到 Git 服务器配置完成后，我们就进入实际使用环节了。 首先我们先修改几个文件，并拷贝到 myfiles 目录下，然后提交到服务端，在 myfiles 下运行提交命令： 123git add .git commit -am "测试提交"git push 带输出的命令行内容： 123456789101112$ git add .$ git commit -am "测试提交"[master (root-commit) ae72bcc] 测试提交 1 file changed, 1 insertion(+) create mode 100644 test.txt$ git pushgit@192.168.252.128's password:Counting objects: 3, done.Writing objects: 100% (3/3), 223 bytes | 223.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To 192.168.252.128:/srv/myfiles.git * [new branch] master -&gt; master 提示输入密码的地方，还是输入的 git 账户的密码。 说明：关于 git 操作的详细命令，请参考 这篇文章 提交成功后，我们在另一台机器上使用命令 git pull 同步最新内容： 1234567891011$ git pullgit@192.168.252.128's password:remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From 192.168.252.128:/srv/myfiles ae72bcc..afad897 master -&gt; origin/masterUpdating ae72bcc..afad897Fast-forward test.txt | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-) 对于多用户的复杂操作，请参考这篇文章 其它配置禁用 git 账户的 shell为了安全考虑，如果需要禁用 git 账户的 shell，可以修改 /etc/passwd 文件： 把其中的 1git:x:1001:1001:git-user,,,:/home/git:/bin/bash 修改为 1git:x:1001:1001:git-user,,,:/home/git:/usr/bin/git-shell 其中 /usr/bin/git-shell 的路径可以通过命令 which git-shell 获得。 使用公匙和私匙实现免密效果上面我们使用的过程中每次都需要输入 git 用户的密码才能和服务端交互，这样会很麻烦，这时候我们可以配置公私匙来实现免密。 首先，需要在客户端生成公私匙： 1ssh-keygen -t rsa 回车后会提示输入私匙的密码，如果要免密就直接回车，否则自定义一个密码(如果自定义了密码，则每次 push 和 pull 时填入的是设置的密码)。 命令执行成功后，会在当前用户目录的.ssh文件夹(Windows 目录是 X:\Users{username}.ssh， Linux 是 /home/{username}/.ssh)生成文件「id_rsa」和「id_rsa.pub」，其中 .pub 文件就是公匙，另一个是私匙。 把文件「id_rsa.pub」拷贝到服务端，并使用如下命令进行设置： 123mkdir /home/git/.sshcp /home/currentuser/Desktop/id_rsa.pub /home/git/.ssh/authorized_keyschown -R git:git /home/git/.ssh 说明，如果 authorized_keys 文件不存在，可以使用 cp 命令，否则请使用 cat 命令追加，比如： 1cat /home/currentuser/Desktop/id_rsa.pub &gt;&gt; /home/git/.ssh/authorized_keys 为了保证配置生效，还需要查看 /etc/ssh/sshd_config 文件中的如下设置是否开启： 1AuthorizedKeysFile %h/.ssh/authorized_keys 是否被注释掉了，如果是，则需要把前面的 # 去掉，并重启 ssh 服务(命令 service ssh restart)。 全部配置完毕后，我们试试效果： 12$ git pullAlready up-to-date. 看，这次没有提示输入密码了吧，免密设置生效。 非 22 端口连接 Git在 .ssh 配置目录现在 config 文件，内容为： 12host ip地址port 端口名 config 配置文件在 Windows 和 Mac 系统的位置为：X:/users/username/.ssh 目录，其中 X 为系统盘， username 为当前登录用户名； 如果是 liunx 系列系统，位置为 /home/username/.ssh 目录，其中 username 为当前登录用户名。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>环境</tag>
        <tag>git server搭建</tag>
        <tag>ubuntu git server</tag>
        <tag>搭建git lab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底搞懂 Python 编码]]></title>
    <url>%2Fpython-coding.html</url>
    <content type="text"><![CDATA[因为中文的特殊编码，导致 Python2 和 Python3 使用过程中的各种编码问题，如果不清楚其中的关联关系，那么这就一直是个大坑，不是懵逼就还是懵逼，所以就目前碰到的情况彻底梳理下 Python2 和 Python3 中编码的关系和区别，以作备忘。 先说下涉及编码格式的几个地方： 脚本字符编码：就是经常在脚本文件开头看到的 # -*- coding: utf-8 -*-，如果使用 Python2，没有显式声明的话默认使用 ASCII 格式，Python3 默认使用 utf-8 格式； 解释器字符编码：可以通过函数 sys.getdefaultencoding() 查看，Python2 默认是 ASCII，Python3 默认使用 utf-8； 脚本文件存储编码：就是 py 脚本文件本身在物理介质上面的存储格式，通常有 ASCII、GBK、utf-8 等格式。 下面我们把上述编码分别在脚本中进行组合使用后，再使用 Python2.6 和 Python3.4 运行，看看实际都什么效果。 1.默认脚本文件编码 + 文件存储使用 gbk脚本内容： 1234import sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果如下，提示gbk 编码字符 \xd6 非 ASCII 字符： 123&gt; python26 test_gbk.py File "test_gbk.py", line 4SyntaxError: Non-ASCII character '\xd6' in file test_gbk.py on line 4, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details 使用 Python3.4 运行的结果如下，提示gbk 编码字符 \xd6 非 utf-8 字符： 123&gt; python26 test_gbk.py File "test_gbk.py", line 4SyntaxError: Non-UTF-8 code starting with '\xd6' in file test_gbk.py on line 4, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details 结论：默认的 gbk 编码中文，Python2的解释器字符编码(ASCII)和 Python3的解释器字符编码(utf-8)格式都没法识别，因为 ASCII 编码不包含中文，而 utf-8 是 3 字节编码，gbk 是 2 字节编码，所以都识别不了了。 2.脚本文件编码 gbk + 文件存储使用 gbk在刚才的脚本头部显式声明脚本文件编码格式为 gbk： 123456#coding:gbkimport sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果：123&gt; python26 test_gbk.pyascii中文 使用 Python3.4 运行的结果：123&gt; python34 test_gbk.pyutf-8中文 结论：文件使用的 gbk 格式存储，同时显式声明了脚本文件编码为 gbk，Python2 和 Python3 都可以正常处理。 3.脚本文件编码 utf-8 + 文件存储使用 gbk在刚才的脚本头部显式声明脚本文件编码格式为 utf-8： 123456# -*- coding: utf-8 -*-import sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果正常： 123&gt; python26 test_gbk.pyascii中文 使用 Python3.4 运行的结果如下，提示尝试使用 utf-8 解码字符 0xd6 时异常： 123&gt; python34 test_gbk.pyFile "test_gbk.py", line 6SyntaxError: (unicode error) 'utf-8' codec can't decode byte 0xd6 in position 0: invalid continuation byte 结论：文件使用的 gbk 格式存储，同时显式声明了脚本文件编码为 utf-8时，但是 Python2 在 Windows 平台还是使用 gbk 进行输出，所以解析正常，而 Python3 使用 utf-8 所以解析异常。 4.默认脚本文件编码 + 文件存储使用 utf-8去掉之前脚本头部的声明，然后使用 utf-8 格式存储文件(注意，不能在刚才的文件基础上强制修改存储编码，强制转换会出现中文乱码的问题，建议先新建一个 utf-8 格式的文件，然后再输入中文)： 1234import sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果如下，ASCII 也识别不了 utf-8 格式的字符 \xe4： 123&gt; python26 test.py File "test.py", line 4SyntaxError: Non-ASCII character '\xe4' in file test.py on line 4, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details 使用 Python3.4 运行的结果，可以正常识别，因为 Python3 默认使用 utf-8 编码： 123&gt; python34 test.pyutf-8中文 结论：默认的 utf-8 编码中文，Python2 会默认使用 ASCII 读取，所以没法识别，Python3 可以正常识别。 5.脚本文件编码 gbk + 文件存储使用 utf-8脚本头部显式声明脚本文件编码格式为 gbk，同时使用 utf-8 格式存储文件： 12345#coding:gbkimport sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果如下，使用 gbk 根本读取不了 utf-8 格式任何内容： 123&gt; python26 test.pyFile "test.py", line 6SyntaxError: 'gbk' codec can't decode bytes in position 9-10: illegal multibyte sequence 使用 Python3.4 运行的结果如下，其实和上面错误一样，但是提示更直接了： 123&gt; python34 test.pyFile "test.py", line 1SyntaxError: encoding problem: gbk 结论：默认的 utf-8 编码中文，如果显式指定使用 gbk 读取，Python2 和 Python3 都没法做到。 6.脚本文件编码 utf-8 + 文件存储使用 utf-8脚本头部显式声明脚本文件编码格式为 utf-8，同时使用 utf-8 格式存储文件： 12345# -*- coding: utf-8 -*-import sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果如下，虽然读取正确了，但是 Python2 在 Windows 系统会默认使用 gbk 对中文进行解码，所以输出乱码： 123&gt; python26 test.pyascii涓枃 使用 Python3.4 运行的结果正常： 123&gt; python34 test.pyutf-8中文 结论：虽然文件存储编码和脚本文件编码都是 utf-8，但是 Windows 平台上，Python2 会按 gbk 解析中文，所以会输出乱码，可以在中文前面加 u 来解决u&#39;中文&#39;，或者显式使用 utf-8 进行一次 decode。 汇总下验证结果，可以得到如下的表格： 不同组合下 Python3 和 Python2 处理结果 Python3 Python2 默认脚本文件编码 + 文件存储使用 gbk SyntaxError，解析错误 SyntaxError，解析错误 脚本文件编码 gbk + 文件存储使用 gbk 正常输出中文 正常输出中文 脚本文件编码 utf-8 + 文件存储使用 gbk SyntaxError，解析错误 正常输出中文 默认脚本文件编码 + 文件存储 utf-8 正常输出中文 SyntaxError，解析错误 脚本文件编码 gbk + 文件存储使用 utf-8 SyntaxError，解析错误 SyntaxError，编码错误 脚本文件编码 utf-8 + 文件存储使用 utf-8 正常输出中文 中文输出乱码 总结下结论： 如果使用 Python2 请一定要使用 gbk 格式存储文件； 如果使用 Python2 尽可能使用 gbk 存储文件且显式声明脚本文件编码为 gbk，方便后续兼容 Python3； 如果使用 Python3 不管使用什么格式存储文件，但请一定保证显式声明脚本文件编码和存储格式一致； 不管是使用 Python2 还是 Python3，保持显式声明脚本文件编码的好习惯； 如果脚本有跨平台需求，推荐使用 Python3 + 脚本文件编码 utf-8 + utf-8 格式存储文件的组合；]]></content>
      <categories>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3编码</tag>
        <tag>中文</tag>
        <tag>utf-8</tag>
        <tag>编码</tag>
        <tag>汉字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python2 和 Python3 中默认编码的差异]]></title>
    <url>%2Fpython-defaultencode.html</url>
    <content type="text"><![CDATA[最近在使用 Python3.4 做一些脚本实现，发现对于编码的处理上和 Python2.6 有很大的不同，就此机会把相关知识做个梳理，方便需要的时候查阅。 先说下概念和差异： 脚本字符编码：就是解释器解释脚本文件时使用的编码格式，可以通过 # -\*- coding: utf-8 -\*- 显式指定解释器字符编码：解释器内部逻辑过程中对 str 类型进行处理时使用的编码格式Python2 中默认把脚步文件使用 ASCII 来处理(历史原因请 Google)Python2 中字符串除了 str 还有 Unicode，可以用 decode 和 encode 相互转换Python3 中默认把脚步文件使用 UTF-8 来处理(终于默认就支持中文了，赞)Python3 中文本字符和二进制分别使用 str 和 bytes 进行区分，也是使用 decode 和 encode 进行相互转换 关于默认脚本字符编码，因为对脚步文件处理的默认编码格式变了，所以很多针对内容的处理，都发生了变化，比如下面这个脚本。 1234import sysprint(sys.getdefaultencoding())print('中文') 使用 Python3.4 解释器运行结果如下： 123&gt; python34 test.pyutf-8中文 使用 Python2.6 解释器运行结果如下： 123&gt; python26 test.py File "test.py", line 4SyntaxError: Non-ASCII character '\xe4' in file test.py on line 4, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details 使用 Python2.6 报错就是因为第一条说的「Python2 中默认把脚步文件使用 ASCII 来处理」，但是脚步文件包含了中文，ascii 又没有覆盖中文，所以报错。如果我们把脚步稍作修改： 123456# -*- coding: utf-8 -*-import sysprint(sys.getdefaultencoding())print('中文') 增加了脚本字符编码的说明，再次使用 Python2.6 解释器运行结果为： 123&gt; python26 test.pyascii涓枃 因为明确指定了脚步文件编码格式为 utf-8，所以读取没问题，也就是说如果 Python2 脚本文件中包含了非 ASCII 字符时，一定要显式指定脚步文件编码格式，对于 Python3 因为默认的脚步文件编码格式就是 utf-8，所以没有这个问题(后面会有文章详细讨论这个问题)。 但是我们回头看下刚才的输出，结果显示为乱码。 乱码就涉及到另一个我们要说的不同点解释器字符编码，因为我们定义了 utf-8 格式读取脚步内容，但是因为 Python2.6 在 Windows 平台上，默认是使用 gbk 对字符进行 decode 输出，不信你看： 1234567891011121314&gt; python26ActivePython 2.6.6.15 (ActiveState Software Inc.) based onPython 2.6.6 (r266:84292, Aug 24 2010, 16:01:11) [MSC v.1500 32 bit (Intel)] onwin32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; s='中文'&gt;&gt;&gt; s'\xd6\xd0\xce\xc4'&gt;&gt;&gt; s.decode('gbk').encode('utf-8')'\xe4\xb8\xad\xe6\x96\x87'&gt;&gt;&gt; print('\xd6\xd0\xce\xc4')中文&gt;&gt;&gt; print('\xe4\xb8\xad\xe6\x96\x87')涓枃 完整描述下上面乱码出现的过程： 使用指定的脚本文件编码 utf-8 格式读取了「中文」，读取到的字符串内容为 ‘\xe4\xb8\xad\xe6\x96\x87’，然后输出时 Python2.6 的解释器使用默认解释器字符编码 gbk 格式对读取内容进行 encode 输出，但是之前 utf-8 是 3 个字节长度表示一个中文，而 gbk 是用 2 个字节长度来表示中文，所以之前的 2 个中文，在输出的时候就按照 3 个中文进行编码(encode)，当然就乱码了，仔细看那个乱码，就是 3 个字。 我们再用代码验证下上面说的内容： 12345678910111213# -*- coding: utf-8 -*-import sysprint(sys.getdefaultencoding())print('中文')print('\xe4\xb8\xad\xe6\x96\x87')print('\xe4\xb8\xad\xe6\x96\x87'.decode('gbk', 'ignore'))print('\xd6\xd0\xce\xc4'.decode('gbk').encode('utf-8'))print('中文'.decode('utf-8'))print('\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8'))print('\xd6\xd0\xce\xc4')print('\xd6\xd0\xce\xc4'.decode('gbk')) 看看输出结果： 12345678910&gt; python26 test.pyascii涓枃涓枃涓枃涓枃中文中文中文中文 很明显 gbk 格式解码的十六进制字符正常输出为中文了，显式使用 utf-8 对 utf-8 格式的十六进制字符进行 decode 也输出正常了。 同理，还可以看到另外 2 个现象： 把 py 文件用 utf-8 格式存储，并且包含「中文」字样时，如果使用 gbk 格式打开，也是看到「中文」显示的乱码和上面程序输出的一致；如果把 py 文件使用 gbk 格式存储，这时候 print(&#39;中文&#39;) 也显示正常了； 乱码的终极原因就是：对同一个字符串的 encode 和 decode 编码格式不一致。 上面说的这个问题，如果文件存储和脚本文件编码都使用 utf-8 时，使用 Python3.4 是没有问题的，因为 Python3 默认的解释器字符编码是 utf-8 了，默认就可以处理中文了。 总结下结论： Python2 脚步文件尽量使用 gbk 格式存储；同理 Python3 脚步文件尽量使用 utf-8 格式存储； Python2 脚步如果带有中文字符时，请务必在脚本开头声明能支持中文的脚本文件编码； Python2 中对同一个字符串的 encode 和 decode 编码格式请保持一致； 说明：本次所有测试脚本文件均保存为 utf-8 格式]]></content>
      <categories>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编码</tag>
        <tag>decode</tag>
        <tag>encode</tag>
        <tag>python3默认编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 三大特性之多态]]></title>
    <url>%2Fjava-duotai.html</url>
    <content type="text"><![CDATA[大家都知道 Java 的三大特性是：封装、继承和多态。今天要介绍的是 Java 三大特性之多态：对象有多种表现形式，具体最终使用哪种形式由最后运行时情况决定。 使用多态必须要达到三个条件： 一个就是需要使用继承 一个就是涉及方法的重写 最后一个就是需要进行向上转型 前期绑定：也叫编译时绑定，主要表现类型是重载(overloading)，比如一个类中有一个或多个名称相同的方法，但是他们参数不同。 举个例子：1234567891011121314public class TestClass &#123; public static void main(String[] str) &#123; testMethod(10); testMethod("This is a string"); &#125; public static void testMethod(int iRet) &#123; System.out.println("int simple"); &#125; public static void testMethod(String sRet) &#123; System.out.println("string simple"); &#125;&#125; 输出结果： int simplestring simple 后期绑定：也叫运行时绑定，主要表现类型就是重写(overriding)，比如子类重写了父类的方法。 举个例子：123456789101112131415161718public class TestClass &#123; public static void main(String[] str) &#123; Father testMethod = new Son(); testMethod.getResult(); &#125;&#125;class Father &#123; public void getResult() &#123; System.out.println("I am a Father"); &#125;&#125;class Son extends Father &#123; public void getResult() &#123; System.out.println("I am the Son"); &#125;&#125; 输出结果为： I am the Son 只有普通的方法调用是可以多态的，直接访问的成员变量是不支持多态的。为了避免混淆，可以把成员变量设置为 private 属性。 举个例子：1234567891011121314151617181920212223public class TestClass &#123; public static void main(String[] str) &#123; Father testMethod = new Son(); System.out.println("testMethod.notMethod = " + testMethod.notMethod + ", testMethod.getNotMethod() = " + testMethod.getNotMethod()); &#125;&#125;class Father &#123; public int notMethod = 0; public int getNotMethod() &#123; return notMethod; &#125;&#125;class Son extends Father &#123; public int notMethod = 1; public int getNotMethod() &#123; return notMethod; &#125;&#125; 输出结果： testMethod.notMethod = 0, testMethod.getNotMethod() = 1 **从结果可以看出来，testMethod.notMethod 获取的是父类的变量的值，而不是子类的，但是 testMethod.getNotMethod() 则是获取子类的方法的返回值。 总结下就是，static 方法和 final 方法属于前期绑定，子类无法重写 final 方法，静态和非静态的成员变量都属于前期绑定。除了 static 方法和 final 方法（ private 属于 final 方法）之外的其他方法属于后期绑定，运行时能判断对象的类型进行绑定。** 来个例子：123456789101112131415161718public class TestClass &#123; public static void main(String[] str) &#123; Father testMethod = new Son(); testMethod.getResult(); &#125;&#125;class Father &#123; public static void getResult() &#123; System.out.println("I am a Father"); &#125;&#125;class Son extends Father &#123; public static void getResult() &#123; System.out.println("I am the Son"); &#125;&#125; 输出结果为： I am a Father 当继承和向上转型同时存在时，函数实现会遵循多态原则进行实际的调用，调用顺序为：this.method(class)、super.method(class)、this.method((super)class)、super.method((super)class)。 来个例子：1234567891011121314151617181920212223242526272829303132333435363738394041public class TestClass &#123; public static void main(String[] str) &#123; Father oneTest = new Father(); Son twoTest = new Son(); Father threeTest = new Son(); Son fourTest = new GrandDaughter(); //this.method(class) threeTest.method(oneTest); //super.method(class) threeTest.method(twoTest); //this.method((super)class) threeTest.method(threeTest); //super.method((super)class) threeTest.method(fourTest); &#125;&#125;class Father &#123; public void method(GrandDaughter grandDaughter) &#123; System.out.println("I am the Granddaughter in Father"); &#125; public void method(Son son) &#123; System.out.println("I am the son in Father"); &#125; public void method(Father father) &#123; System.out.println("I am the Father in father"); &#125;&#125;class Son extends Father &#123; public void method(Father father) &#123; System.out.println("I am the Father in Son"); &#125;&#125;class GrandDaughter extends Son &#123;&#125; 输出结果为： I am the Father in SonI am the son in FatherI am the Father in SonI am the son in Father 构造器方法默认都是 static 属性的，所以不支持多态。当时基类的构造器总是在子类的构造过程中被调用，而且按照继承层次逐级依次调用。 举个例子：1234567891011121314151617181920212223public class TestClass extends GouZaoQiThree&#123; public static void main(String[] str) &#123; new TestClass(); &#125;&#125;class GouZaoQiOne &#123; GouZaoQiOne() &#123; System.out.println("This is GouZaoQiOne"); &#125;&#125;class GouZaoQiTwo extends GouZaoQiOne&#123; GouZaoQiTwo() &#123; System.out.println("This is a GouZaoQiTwo"); &#125;&#125;class GouZaoQiThree extends GouZaoQiTwo&#123; GouZaoQiThree()&#123; System.out.println("This is GouZaoQiThree"); &#125;&#125; 输出结果： This is GouZaoQiOneThis is a GouZaoQiTwoThis is GouZaoQiThree 好了，作为 Java 的三大特性之一，多态在实际项目过程的使用会非常广泛，上述说明还需要在实践中多加锻炼才行。]]></content>
      <categories>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>封装</tag>
        <tag>java三大特性</tag>
        <tag>继承</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 三大特性之继承]]></title>
    <url>%2Fjava-jicheng.html</url>
    <content type="text"><![CDATA[前两天我们说了 Java 三大特性之封装，今天主要说说三大特性之继承。 下面我们会通过继承的特点和对应的例子来分别进行说明。 子类拥有父类非 private 的属性，方法。子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。子类可以用自己的方式实现父类的方法。 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestClass &#123; public static void main(String[] str) &#123; Son simple = new Son(); simple.method(); simple.printStr(); simple.method("simple"); &#125;&#125;class Father &#123; //父类的非private属性，子类也可以访问和使用 public String str = "Simple"; Father() &#123; System.out.println("This is the Father's " + str); &#125; //父类的非private方法，子类可以调用 public void method() &#123; System.out.println("This is the Father's method"); &#125; public void method(String strs) &#123; System.out.println("This is the Father's method with param"); &#125;&#125;class Son extends Father &#123; //子类可以拥有自己的属性 private String ownStr = "ownStr"; Son() &#123; super(); System.out.println("This is the Son's " + super.str); &#125; //子类可以拥有自己的方法 public void printStr() &#123; System.out.println("This is the " + "Son's method"); &#125; //子类可以重写父类的方法 public void method(String strs) &#123; System.out.println("This is the Son's method, " + "which is overriding from Father"); &#125;&#125; ​输出结果： This is the Father’s SimpleThis is the Son’s SimpleThis is the Father’s methodThis is the Son’s methodThis is the Son’s method, which is overriding from Father Java 的类继承是单继承，但是接口可以使用关键字 implements 实现多重继承(例子会在后面讲接口的时候详细说明)。子类会默认调用父类的无参数构造器，但是如果父类没有无参构造器，子类必须要显式的指定父类的构造器(有参数)，而且必须是在子类构造器第一行进行调用。 例子：12345678910111213141516171819202122232425262728293031public class TestClass &#123; public static void main(String[] str) &#123; new GouZaoQiTwo(); new GouZaoQiFour("simple"); &#125;&#125;class GouZaoQiOne &#123; GouZaoQiOne() &#123; System.out.println("This is GouZaoQiOne"); &#125;&#125;class GouZaoQiTwo extends GouZaoQiOne&#123; //子类会默认调用父类的无参数构造器&#125;class GouZaoQiThree &#123; GouZaoQiThree(String str) &#123; System.out.println("This is the gouzaoqi with param."); &#125;&#125;class GouZaoQiFour extends GouZaoQiThree&#123; GouZaoQiFour(String str)&#123; //如果父类没有无参构造器，子类必须要显式的指定父类的构造器(有参数)， //而且必须是在子类构造器第一行进行调用 super(str); System.out.println("This is GouZaoQiFour"); &#125;&#125; 输出结果： This is GouZaoQiOneThis is the gouzaoqi with param.This is GouZaoQiFour 继承后类型支持向上转型，比如 B 继承 A，那么B的实例也属于 A 类型。 例子： 12345678910111213141516171819public class TestClass &#123; public static void main(String[] str) &#123; GouZaoQiTwo gouZaoQiTwo = new GouZaoQiTwo(); //method方法的参数实际要求的类型是GouZaoQiOne， //但是因为GouZaoQiTwo是GouZaoQiOne的子类， //所以可以通过向上转型来满足参数类型的需要 gouZaoQiTwo.method(gouZaoQiTwo); &#125;&#125;class GouZaoQiOne &#123; public void method(GouZaoQiOne gouZaoQiOne) &#123; System.out.println("This is GouZaoQiOne"); &#125;&#125;class GouZaoQiTwo extends GouZaoQiOne&#123;&#125; 继承提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系），慎用继承。 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestClass &#123; public static void main(String[] str) &#123; ZiXingChe ziXingChe = new ZiXingChe("sylan215"); DianDongChe dianDongChe = new DianDongChe("sylan215-1"); ziXingChe.run(); ziXingChe.sleep(); ziXingChe.reboot(); dianDongChe.run(); dianDongChe.sleep(); dianDongChe.power(); &#125;&#125;class ZiXingChe &#123; private String name; ZiXingChe(String name) &#123; this.name = name; System.out.println("This is a " + name); &#125; public void run() &#123; System.out.println("I am a " + this.name + ", I can run"); &#125; public void sleep() &#123; System.out.println("I am a " + this.name + ", I need sleep"); &#125; public void reboot() &#123; System.out.println("I am a " + this.name + ", I need reboot"); &#125;&#125;class DianDongChe &#123; private String name; DianDongChe(String name) &#123; this.name = name; System.out.println("This is a " + name); &#125; public void run() &#123; System.out.println("I am a " + this.name + ", I can run"); &#125; public void sleep() &#123; System.out.println("I am a " + this.name + ", I need sleep"); &#125; public void power() &#123; System.out.println("I am a " + this.name + ", I need power"); &#125;&#125; 输出结果为： This is a sylan215This is a sylan215-1I am a sylan215, I can runI am a sylan215, I need sleepI am a sylan215, I need rebootI am a sylan215-1, I can runI am a sylan215-1, I need sleepI am a sylan215-1, I need power 看看合并后的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TestClass &#123; public static void main(String[] str) &#123; ZiXingChe ziXingChe = new ZiXingChe("sylan215"); DianDongChe dianDongChe = new DianDongChe("sylan215-1"); ziXingChe.run(); ziXingChe.sleep(); ziXingChe.reboot(); dianDongChe.run(); dianDongChe.sleep(); dianDongChe.power(); &#125;&#125;class CheZi &#123; private String name; CheZi(String name) &#123; this.name = name; System.out.println("This is a " + name); &#125; public void run() &#123; System.out.println("I am a " + this.name + ", I can run"); &#125; public void sleep() &#123; System.out.println("I am a " + this.name + ", I need sleep"); &#125;&#125;class ZiXingChe extends CheZi &#123; private String name; ZiXingChe(String name) &#123; super(name); this.name = name; &#125; public void reboot() &#123; System.out.println("I am a " + this.name + ", I need reboot"); &#125;&#125;class DianDongChe extends CheZi &#123; private String name; DianDongChe(String name) &#123; super(name); this.name = name; &#125; public void power() &#123; System.out.println("I am a " + this.name + ", I need power"); &#125;&#125; 输出结果为： This is a sylan215This is a sylan215-1I am a sylan215, I can runI am a sylan215, I need sleepI am a sylan215, I need rebootI am a sylan215-1, I can runI am a sylan215-1, I need sleepI am a sylan215-1, I need power 总结下继承的特点： 子类拥有父类非 private 的属性、方法； 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展； 子类可以用自己的方式实现父类的方法； Java 的类继承是单继承，但是接口可以使用关键字 implements 实现多重继承； 子类会默认调用父类的无参数构造器，但是如果没有默认(无参数)的父类构造器，子类必须要显式的指定父类的构造器(有参数)，而且必须是在子类构造器中做的第一件事； ​继承后类型支持向上转型，比如 B 继承 A，那么B的实例也属于 A 类型; 继承提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系），慎用继承；]]></content>
      <categories>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>封装</tag>
        <tag>java三大特性</tag>
        <tag>继承</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 三大特性之封装]]></title>
    <url>%2Fjava-fengzhuang.html</url>
    <content type="text"><![CDATA[学习Java，必须得了解Java的三大特性(封装、继承和多态)，今天就说说三大特性之一的封装。 封装就是把属性私有化，然后提供公共的方法来访问私有属性。 概念性的东西大家上网搜一下就行，下面我们分别举例说明封装的几个好处。 1.可以隐藏一些私有属性和一些实现过程。先看看封装前的代码： 123456789101112131415161718192021public class TestClass &#123; public static void main(String[] str) &#123; Flower newFlower = new Flower(); newFlower.name = "JuHua"; newFlower.chanDi = "China"; newFlower.time = 10; newFlower.xiShui = false; Flower twoFlower = new Flower(); twoFlower.name = "GuiHua"; twoFlower.chanDi = "China"; twoFlower.time = 30 twoFlower.xiShui = false; &#125;&#125;class Flower &#123; public String name;//花名 public int time;//最长花龄 public String chanDi;//产地 public boolean xiShui;//是否喜水&#125; 再看看封装后的代码： 1234567891011121314151617181920public class TestClass &#123; public static void main(String[] str) &#123; Flowers flowerSimple = new Flowers("JuHua", 10, "China", false); Flowers flowerSimple2 = new Flowers("GuiHua", 30, "Juke", false); &#125;&#125;class Flowers &#123; private String name;//花名 private int time;//最长花龄 private String chanDi;//产地 private boolean xiShui;//是否喜水 Flowers(String name, int time, String chanDi, boolean xiShui) &#123; this.name = name; this.time = time; this.chanDi = chanDi; this.xiShui = xiShui; &#125;&#125; 很明显，我们把类的属性给做了隐藏处理，然后使用公共的构造函数提供对外操作的入口，构造函数的实现过程也保持了对外的隐藏。 2.可以对赋值的属性进行一些代码处理，让代码逻辑更准确。 比如上面的例子中，封装前，对属性的初始化赋值是没有做任何兼容处理的，如果设置 newFlower.time = 100000; 程序不会报错，但是没有实际应用的意义了，所以也不能满足产品兼容性的要求，但是也没法进一步处理，而通过封装就可以很好的进行这种特殊处理。看代码： 1234567891011121314151617181920212223242526public class TestClass &#123; public static void main(String[] str) &#123; Flowers flowerSimple = new Flowers("JuHua", 100000, "China", false); &#125;&#125;class Flowers &#123; private String name;//花名 private int time;//最长花龄 private String chanDi;//产地 private boolean xiShui;//是否喜水 Flowers(String name, int time, String chanDi, boolean xiShui) &#123; this.name = name; //对传入的参数进行合理性校验，如果是封装前，肯定做不到这个效果 if (time &gt; 10000) &#123; System.out.println("The number is too big"); &#125; else &#123; this.time = time; &#125; this.chanDi = chanDi; this.xiShui = xiShui; &#125;&#125; 输出结果： The number is too big 3.可以在需要修改时只改变封装函数即可。 还拿第一个例子来说，如果是封装前，我们需要把 time 的类型改成 String，那么我们就需要在每个初始化的地方去修改初始化值为 String 类型，但是封装后则只需要做个简单处理即可，看代码： 1234567891011121314class Flowers &#123; private String name;//花名 private String time;//最长花龄，换成String类型了 private String chanDi;//产地 private boolean xiShui;//是否喜水 Flowers(String name, int time, String chanDi, boolean xiShui) &#123; this.name = name; //不修改任何实现，只是把传入的int通过String.valueof进行下类型转换即可 this.time = String.valueOf(time); this.chanDi = chanDi; this.xiShui = xiShui; &#125;&#125; 最后再总结下封装的好处： 1.可以隐藏一些私有属性和一些实现过程；2.可以对赋值的属性进行一些代码处理，让代码逻辑更准确；3.可以在需要修改时只改变封装函数即可。]]></content>
      <categories>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>封装</tag>
        <tag>java三大特性</tag>
        <tag>继承</tag>
        <tag>多态</tag>
      </tags>
  </entry>
</search>
