<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[是的，你知道的真相都是假的]]></title>
    <url>%2F20171121-zhenxiang.html</url>
    <content type="text"><![CDATA[随着互联网的普及，人们获取知识的速度加快，数量更是呈指数级增长。 于是有人说，之前的信息不平等状况就此被打破，任何人都可以最快时间获取到最新最全最真实的信息。 这是「真相」吗？ 我们先来看几个例子。 MH370 调查前几天刷屏的《马航 MH370 调查》(终结篇)，相信不少人都看了，和其他所有有争议的内容一样，刷屏的结果就是大家都很快开始站队了。 同样的内容，有人觉得是阴谋论，有人觉得是背后的真相，那事实到底是什么呢？ 别问我，我也不知道。 我知道的是，针对任何事情都不能以偏概全，我们只需要去了解足够多的信息，然后得出自己的结论即可。 江歌案还有不得不提的江歌案，这个是比马航争议更大的事件。 通过网上各种事实的披露，很快就形成了三个不同关注点的人群，关注江歌的、关注刘鑫的以及关注陈世峰的。 每个人都有自己的观点，而且看起来都特别有道理，当然也都有一个共性，都是基于事实中的某一部分内容来印证自己的观点。 这个我也有观点：过去的事情我们无力改变，但是我们可以尽力保证以后不在发生类似的事情。 谨记，交友需谨慎。 货币战争提到真相，阴谋论，很多人都能第一印象的想起备受争议的《货币战争》，比如和菜头在他的《怎样用最快速度赚到人生中的第一个一百万》中，就自然的把这个事情进行了关联。 相对江歌案来说，货币战争和 MH370 的真相报道的性质更相似，都是基于大众所不知道的信息，进行完美的推理演绎，看的人很快就进入状态，从而情绪被带动，自然的入戏。 这也是这种事情能够吸引人的原因，人类天生都有好奇心，天生都有追求「真相」的强烈驱动。 世界不是绝对的，入戏太深的时候，切记抬头看看自己是否是真实的存在。 转基因几乎所有的「真相」都伴随着争议。 对于「转基因」的争议更是持续了数年，理论上来说，转基因属于科学研究的范畴，也就是说，它所谓的好与坏，应该是有一个绝对明确的结论。 但遗憾的是，并没有。 支持和反对的双方，仍然是从庞大的信息集合中，摘取自己需要的部分，进行放大、引导，然后得出自己的结论。 是的，你知道的真相都是假的，这个世界根本没有真相，只有利益。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>真相</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我认识的老周(三)]]></title>
    <url>%2F20171115-dianfuzhe3.html</url>
    <content type="text"><![CDATA[终于看完《颠覆者》第九章了，继《我认识的老周》、《我认识的老周(二)》之后，终于看到老周花了将近 80 页所回忆的关于 3721 的故事。 如果只是从篇幅来说，80 页是本书中篇幅最长的章节，如果从内容来讲，1998 到 2003 年这 5 年的跨度，共分成了 14 个小节来讲，无不说明老周对于 3721 这次创业的不释怀。 下面是我读完之后，对老周更深的了解，欢迎一起探讨。 抗压能力超强从事业部总经理到马连洼的创业者，从有稳定工作和不俗的待遇到资金捉襟见肘，这个巨大的转变没有让老周有丝毫的退却，他眼中看到的是光明的未来。 从 1998 年 10 月到 1999 年 6 月，老周一边盯开发，一边寻求融资，不断找人约谈，先后见了中公网的谢文、一个朋友的清华同学、263 创始人李小龙、联想刘晓林，每一次约谈都是一次打击，能给列出来的都是有明确记录的，没有列出来的应该就更多了，如果仅仅把老周看成程序员的话，那是绝对做不成这个事情的，此时，他兼具了产品、开发、销售等多重角色，同样也是承担了多重压力。 万幸的是，IDG 主动找上门，并且完成了第一次 200 万融资。 这还不算完，千辛万苦融资来的 200 万，很快就花完了，差点就资金链断裂，而第二轮的融资承诺却打了水漂，当然最终还是度过难关，但是这个过程的煎熬肯定不是常人所能想象的到的。 条件艰苦和融资怎么说还都是自己可控的，可以自己去努力达成目标的，但是后面碰到的 RealNames 和 CNNIC 却是狼一样的对手。 一个号称有微软支持，掌握着可怕的杀手锏；一个号称有政府背景，处处称自己掌握国家标准。 这两个对手的出现，让公司没时间去考虑能否挣钱，必须先考虑能否存活。 那种焦灼又无可奈何的感觉，只有时间才能缓解，而事实上也是时间解决了问题，经过一系列战斗，备受煎熬之后，2002 年 10 月，3721 和微软达成战略联盟。 结局是让人欢喜的，过程却是无比痛苦的，老周的几处描述可以更好的说明： 市场竞争，绝不会留给竞争者闪烁一个悲伤眼神的时间。你以为自己已经跌到了谷底，其实还有更深的深渊在前方等待。 反抗到底「CNNIC 公然宣战时，当时公司的 CEO 建议缴械投降」，如果不是被逼到绝境，就算是职业经理人也不会这么建议吧，当时的境况确实是毫无胜算可言，抗争也只是殊死一搏，就算是抗压能力超强的老周，也感到恐惧。 我第一次感觉到，我的公司可能随时就会关门。我最担心的事情是半夜电话铃声会突然响起，电话那边通知我可怕的事情终于发生了。 而这种时候，老周没有忘记的还是反抗。 立刻发表了措辞严厉的《严正声明》、信息产业部内部会议上的激情演讲、所有公共场合可以利用的机会都被老周用来陈述真相。 「大炮」在这时候开始名声在外了。 如果我选择沉默，我的企业就会沉没。我一定会反击，而且会反击到底。 接下来的反抗是和百度的技术战，百度在推广自己的插件时会强制卸载 3721，这让倔强的老周忍无可忍，对于无视规则的人，必须用更高的代价 Fuck 回去，造成的影响就是，用户的浏览器成了战场，各种插件都很难找到手动卸载入口，最终导致 3721 背上了「流氓软件」的骂名。 为了生存，有些手段也是迫不得已，老周自己也在事后做了总结，并在后续创业过程中严格恪守这些底线，但是整个过程，如果没有强大的内心，以及反抗到底的信念，是绝对坚持不下去的。 在后来的奇酷事件中，老周「反抗到底」的性格，也是得到了淋漓尽致的体现。 主动出击老周从来都不是，也不会是待宰的羔羊。 当知道 RealNames 与微软合作并要入驻中国时，主动找到 RealNames 寻求合作，虽然最终没有成行，但是老周无疑是尽力了。 当知道 CNNIC 和 3721 业务的关联关系后，主动和 CNNIC 磋商和讨论合作适宜，最终因为霸王条款双方没有达成一致。在大战爆发前，老周又主动找到了 CNNIC 的身份疑点，并加以确认，为后面开战提供了有力的事实和道义支援。 当知道百度做搜索时，也是先主动寻求合作，而在合作未果的情况下，才不得不去应对百度发起的攻击。 甚至到后来，为了对抗百度，还主动寻求与 Goggle 的合作，不过最终无疾而终。 以上种种，不管结果如何，老周都是能很快发现问题，并主动去解决问题的人，一方面能说明他对问题的敏感度非常高，另一方面也看出老周从来都不会坐以待毙。 将近 80 页的内容，详尽的描述了 3721 从创立到卖身的整个过程，不难看出老周对 3721 的深厚感情，而其中穿插的关于和搜索失之交臂的事情，应该是对老周影响最大的心结了。 这么倔强的老周，迟早都要去解开这个心结的。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>颠覆者</tag>
        <tag>360</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我认识的老周(二)]]></title>
    <url>%2F20171113-dianfuzhe2.html</url>
    <content type="text"><![CDATA[上一篇我认识的老周写完时，《颠覆者》刚读完第四章，这几天看到了第九章，因为看的时候也在做笔记，所以速度上就慢一点。 前四章的时间跨度是 1970 年到 1988 年，刚好到高中毕业，如果用一个词来形容前四章中老周给我的印象，那就是「学霸」。 从第五章到第八章的时间跨度是 1988 年到 1998 年，完成整个大学的课程，以及在方正工作的三年时间，如果再用一个词来形容老周这十年经历给我的印象，那就是「坚韧」。 如果再说的具体点，我可以从下面几个方面进行总结： 1. 无人匹敌的商业头脑这十年中老周对于商业和创业的追求，无不实际体现了他所具备的敏锐的商业头脑。 先说他的第一次商业行为。 1988 年，18 岁，就想到了回收旧书并在学校门口练摊，其实也不是空想的，是刚到大学时从师兄师姐那观察来的，试想想，有多少人在 18 岁的时候就有这么敏锐的观察力，虽然只是依葫芦画瓢，但是这方面的意识必须给个赞。 这还不算完，在练摊的过程中，他又观摩学习到了一个新的商机：科学算命，而且说干就干，半小时就搞定了程序实现，接着顺利的进行了商业落实，效果出奇的好，很快就挣到了一笔巨款。 练摊和科学算命都是小打小闹，虽然挣钱了但还算不上创业，老周的眼光也不会局限于此，所以又有了接下来的两次创业。 1993 年，23 岁，和同学联合创业，生产硬件为主的反病毒卡，虽然最后以失败告终，但是这个项目本身是挣钱的，失败是因为管理方面的问题，老周这次的商业意识也是正确的。 1994 年，24 岁，再次创业，这次是软件为主的平面广告创意系统，同样以项目失败告终，但是更多家的类似公司却都活过来了，这次的商业意识也是没问题，依然是公司管理上的问题。 不管是大的项目还是小的项目，只是从项目本身来说，以上几个都是绝好的点子，但是最终落实时，却并不全尽如人意，说明老周的商业意识是没有问题，而为了成就更伟大的事业，他需要在其他方面进行充电，所以研究生时保送的是管理专业。 2. 自信且坚韧不拔老周对自己确定的事情总是十分自信，一旦确定目标就坚决的去做，并且坚持去做。 在第一次创业的反病毒卡项目中，自己只身前往特区采购，虽然遭遇「卖猪仔」，依然完成采购任务，在之后的采购过程中，也是不断收集各种软件，并回家逐个学习，给后续的创业打下了坚实的基础。 在那个钱还非常值钱的年代，能够自行销售售价 298 元的反病毒卡几十套，然后通过代理又卖出一两千张，这样的业绩不能不让人称赞。 其中他轻描淡写的推销过程，应该是比开发过程更加艰难的，他没有用太多的笔墨去描述，更多的去关注所有经历过程中正向的部分，会对他后续创业有价值的部分，同时不断的从反向的部分中反思和总结。 比如第一次反病毒卡项目失败后，老周看到的是自己学到的东西： 我学到了很多：真实的产品和实验室产品的区别、如何与渠道代理商进行沟通、怎么进行商业谈判、如何和创始团队做沟通、怎么进行团队建设和管理。 并且明确自己对失败的态度： 我不再把失败看作是一个挫折或不祥之兆，我把失败看作一条进入前方风景的必经之路。 这个项目很好的体现了老周的自信和坚韧不拔，后续项目中也有同样的体现。 创办「信心」时，因为需要字库，结果同学出价 3000，老周竟然没有丝毫犹豫，当天就凑齐了钱，但是这样他自己就一无所有了，按他的话说： 我就是这样一个人，一旦决定做一件事，就要排除一切困难去做到。 连续遭遇的反病毒卡项目失败、「信心」项目失败、「飞扬」项目失败，一点也没有浇灭他的创业激情，反而在这条路上越走越远，当然也是越来越成功，这一切都跟他的自信和坚韧不拔不无关系。 3. 抓住机会学习一切知识先说下书中有提到一个细节。 在反病毒卡项目中，有这样的描述： 我们的产品(反病毒卡)在强手如林的竞争中获得了「挑战杯」的二等奖。 在「信心」筹备阶段，有这样的描述： 当时我顺手参加了一个陕西大学生的创意大赛，得到了一等奖。 在创业失败，面试方正时，有这样的描述： 简历上看不出我在研究生期间逃过那么多课，我又获得过很多各种大赛的奖。 列举这些，只想说明一件事，老周是个「学霸」，虽然没有好好上课，但是他在抓住一切机会学习，学习那些他认为有用的知识。 比如老周大四的时候，在一家软件开发公司上班时，热衷于参加公司的商业活动，并且在卖出一套设备后，自告奋勇的申请去北京提货，这次经历让他不仅买到了设备，还学习到了怎么开发票、怎么办理运输等一整套流程。 同样是在这家公司，在给电脑培训班站台期间，没有因为用户都是小白，就不耐烦，反而「开始为这些小白用户精心地备课，绞尽脑汁想出最通俗易懂的语言，让计算机语言尽量变成白话」。 同样的事情，如果换作是我，肯定不会这么淡定，甚至能化困境为契机。 比你聪明的人比你还努力，这就是差距。 至此，本书的故事已经进行了一半，后面将是更精彩的 3721 的始末，以及 360 的创办历程，期待。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>颠覆者</tag>
        <tag>360</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我认识的老周]]></title>
    <url>%2F20171110-dianfuzhe.html</url>
    <content type="text"><![CDATA[10 月 24 号，老周新书《颠覆者》在京东预售，我立马预定了一本，11 月 6 号书终于拿到手。 因为是预售，送货比平时慢了点，但还是比大多数人都早拿到手，书挺厚的，将近 400 页，预售是 35.5 人民币，挺值的。 打开包装后，立马有一股淡淡的书香扑鼻而来，那是纸质的味道。 去掉封皮就迫不及待的翻看了目录，第一感觉就是用的纸真心的不错，是我今年读过的书中质量最好的了，纸张的厚度和手感那是杠杠的，这倒很符合老周的性格—实在，做什么事情都是满满的诚意。 上班时间比较忙，就只细看了开头一页的照片，只是从照片看，完全看不出老周所说的「不羁」，当然也看不出他实际表现出来的聪明。正应了那句老话「人不可貌相」。 这几天利用早上的时间，把头四章先看完了，已经禁不住的要发一些感慨了，所以就有了下面的文字。 首先，老周真的太聪明。 小学一年级就直接跳级，虽然最后因为个子小被强行安排到二年级，但是一直「吃不饱」还是很好的说明了他的聪明程度，只用了三分之一的精力就搞定了学校的功课，我的天，厉害(想想现在辅导闺女作业的场景，哎，头疼)。 最主要的是，过剩的精力并没有浪费掉，小小的年纪就开始利用这些时间看《林海雪原》、《敌后游击队》、《金银岛》、《水浒传》、《三国演义》和《西游记》，要知道，我是上了大学才看的《三国演义》，难怪自己目前写个东西出来都这么费劲，赶紧找个旮旯补习去。 还有一个体现老周聪明的地方就是升学考试，虽然整天看他调皮捣蛋、吊儿郎当的样子，但是初中他考了十分牛的郑州八中，之后又考上了郑州最好的高中–郑州一中，在转校到不是特别牛的郑州九中后，成绩依然名列前茅，最后成功拿到西安交大的保送名额。 我只想说一个字，大写的服。 印象第二点，「熊孩子」。 换一个词就是，恶作剧。 具体表现就是 上课说话、做小动作不在话下；被老师点名、叫到教室前面罚站成了家常便饭。 还自学了画画，画出老师猪头样式的漫画像，「栩栩如生」，并在全班传阅。 还会翻墙到学校去把教鞭掰成两截，让老师在第二天用的时候出丑。 这些藐视权威的做法，和我理解的熊孩子如出一撤，这也不禁让我想起自己一年级被罚站的场景，真真切切。 第三点，清晰的自我认知和定位。 从小就有自己的主见，对于自己喜欢的东西和事情，总是立马行动，比如小学和初中时期，分别经历过读书、画画、无线电、集邮等等，都是喜欢了就立马去做了，都还做的不赖；比如初中时因为看上了一个玩具，甘心拿自己最喜欢的开国大典邮票和朋友交换，目的性非常明确，不会计较一时得失。 当然确定最终的职业目标还是在高中的时候。 他在高二的一次班会中说到 我的理想很明确，我这辈子就要做一个电脑软件的开发者。做一款产品，改变世界。 要知道很多人到大学毕业，甚至工作很多年之后，依然有不明白自己的目标和方向的。这么早就确定了正确的目标，并持之以恒的坚持，并最后真的实现了愿望，不得不说不太八面玲珑的老周是值得佩服的。 最后一点，感恩的心。 从目前的几篇文字来看，老周对他小学五年级的数学老师王芙蓉、高中班主任徐良都是印象深刻，并十分感激的。 比如王芙蓉老师，是他在 5 年小学期间唯一感谢的老师，因为王老师的包容，让他放下了自己「不羁」的面具，从而在数学上花费了不少力气去学习，恰好也为后面的计算机学习打好了基础。 另一位徐良老师，则是老周在第四章开篇就提到的老师，是除了王芙蓉老师之后另一个让自己信服的老师，也因为徐良老师，让自己对物理的兴趣有了发挥和释放的地方。 对于这一点，老周的原话是这样的： 转入九中之前，除了小学期间的王芙蓉老师，我遇到的老师都是对抗型的，直到遇到我的高中班主任徐良老师。 好了，才看了五分之一，先简短汇总到这，我要继续读去了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>颠覆者</tag>
        <tag>360</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 tinypng 进行批量压缩]]></title>
    <url>%2F20171109-compress-with-tinypng.html</url>
    <content type="text"><![CDATA[不管是博客还是产品中，都会涉及图片的使用，但是如果图片体检太大，会影响使用体验，所以网上有各种各样的支持图片压缩的网站，tinypng 是其中的佼佼者。 今天要介绍的就是如何通过 python 脚本实现一键压缩。 直接上脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- coding: utf-8 -*-"""脚本功能说明：使用 tinypng，一键批量压缩指定文件(夹)所有文件"""import osimport sysimport tinifytinify.key = "你自己申请的 key" # AppKeydef get_file_dir(file): """获取文件目录通用函数""" fullpath = os.path.abspath(os.path.realpath(file)) return os.path.dirname(fullpath)def check_suffix(file_path): """检查指定文件的后缀是否符合要求""" file_path_lower = file_path.lower() return (file_path_lower.endswith('.png') or file_path_lower.endswith('.jpg') or file_path_lower.endswith('.jpeg'))def compress_by_tinypng(input_file): """使用 tinypng 进行压缩，中文前面的 u 是为了兼容 py2.7""" if not check_suffix(input_file): print(u'只支持png\\jpg\\jepg格式文件：' + input_file) return file_name = os.path.basename(input_file) output_path = os.path.join(get_file_dir(sys.argv[0]), 'tinypng') output_file = os.path.join(output_path, file_name) print(output_file) if not os.path.isdir(output_path): os.makedirs(output_path) try: source = tinify.from_file(input_file) source.to_file(output_file) print(u'文件压缩成功：' + input_file) old_size = os.path.getsize(input_file) print(u'压缩前文件大小：%d 字节' % old_size) new_size = os.path.getsize(output_file) print(u'文件保存地址：%s' % output_file) print(u'压缩后文件大小：%d 字节' % new_size) print(u'压缩比： %d%%' % ((old_size - new_size) * 100 / old_size)) except tinify.errors.AccountError: print(u'Key 使用量已超，请更新 Key，并使用命令[Usage] %s [filepath] [key]运行' % os.path.basename(sys.argv[0]))def check_path(input_path): """如果输入的是文件则直接压缩，如果是文件夹则先遍历""" if os.path.isfile(input_path): compress_by_tinypng(input_path) elif os.path.isdir(input_path): dirlist = os.walk(input_path) for root, dirs, files in dirlist: for filename in files: compress_by_tinypng(os.path.join(root, filename)) else: print(u'目标文件(夹)不存在，请确认后重试。')if __name__ == '__main__': len_param = len(sys.argv) if len_param != 2 and len_param != 3: print('[Usage] %s [filepath]' % os.path.basename(sys.argv[0])) elif len_param == 3: tinify.key = sys.argv[2] check_path(sys.argv[1]) else: check_path(sys.argv[1]) 使用说明1. 请先安装 tinify 的依赖库：1python -m pip install tinify 2. 申请 tinify key到 https://tinypng.com/developers 申请自己的 key，每个 key 每个月可以压缩 500 个文件。 3. 执行脚本申请完 key 之后，更新到代码段中的：1tinify.key = "your key" # AppKey 然后带参数执行脚本即可。 带的第一个参数是必选的，可以是文件，也可以是文件夹。 第二个参数是可选的，自定义 key，如果输入了第三个参数，则优先使用自定义 key。 压缩后的文件，默认输出到当前脚本所在目录下的 tinypng 文件夹中，如果要输出到其他位置，可以自行修改脚本实现。 PS：已使用 Python2.7 和 Python3.4 亲测有效，其他 Python 版本如果有异常，请反馈。 更详细的说明请跳转到项目地址：https://github.com/sylan215/compress-with-tinypng，欢迎大家 star，并一起丰富这个脚本的功能。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>环境</tag>
        <tag>tinypng</tag>
        <tag>存储格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存不足导致 nginx 崩溃的原因分析]]></title>
    <url>%2F20171108-OOM-openfiles.html</url>
    <content type="text"><![CDATA[最近在 Centos7 上搭建 nginx 作为 web 服务器使用，但是使用过程中，nginx 总是莫名其妙的崩掉，使用命令 dmesg 检查错误信息如下： 12[6655217.659132] Out of memory: Kill process 11494 (lsof) score 10 or sacrifice child[6655217.659567] Killed process 11494 (lsof) total-vm:161160kB, anon-rss:42368kB, file-rss:0kB, shmem-rss:0kB 使用命令 cat /var/log/nginx/error.log 来查看 nginx 的错误日志包含如下信息: 122017/10/26 22:59:45 [crit] 13093#0: accept4() failed (23: Too many open files in system)2017/10/26 22:59:45 [crit] 13092#0: accept4() failed (23: Too many open files in system) 经过高人指点，是系统配置设置没法满足当前的使用量，准确点说是系统的 open files (打开文件数目)配置的太低了。 使用命令 ulimit -a 看一下当前置： 12345678910111213141516core file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 15089max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 1024pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 15089virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 可以看到 open files 值，只有 1024，下面我们就详细说一下如何在 Centos 系统级别提高打开文件数目(open files)的限制。 详细步骤： 使用命令 sudo bash 切换到 root 账户； 使用 vi/vim 编辑 /etc/sysctl.conf 增加一行 fs.file-max = 100000，下面是修改后的结果： 12345678910[root@test /]# cat /etc/sysctl.conf# System default settings live in /usr/lib/sysctl.d/00-system.conf.# To override those settings, enter new settings here, or in an /etc/sysctl.d/&lt;name&gt;.conf file## For more information, see sysctl.conf(5) and sysctl.d(5).net.ipv6.conf.all.disable_ipv6 = 1net.ipv6.conf.default.disable_ipv6 = 1net.ipv4.tcp_challenge_ack_limit = 999999999kernel.kptr_restrict = 1fs.file-max = 100000 使用 vi/vim 编辑 /etc/security/limits.conf，并在末尾增加如下语句，用来增加所有用户的软硬句柄和文件打开数目限制： 12* soft nofile 100000* hard nofile 300000 下面是修改后的结果： 12345[root@test /]# cat /etc/security/limits.conf# 省略的内容# End of file* soft nofile 100000* hard nofile 300000 执行命令 sysctl -p 让修改生效； 通过命令 whereis nginx 查看 nginx 配置文件所在位置： 12[root@test /]# whereis nginxnginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man3/nginx.3pm.gz /usr/share/man/man8/nginx.8.gz 使用 vi/vim 编辑 /etc/nginx/nginx.conf 来在 nginx 级别上提高打开的文件句柄限制： 12345678[root@test /]# cat /etc/nginx/nginx.conf# 省略的内容user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;worker_rlimit_nofile 300000;# 省略的内容 使用 reboot 命令重启系统后，我们分别使用 ulimit -Hn、ulimit -Sn 和 ulimit -a 来查看修改后的效果： 123456789101112131415161718192021[root@test /]# ulimit -Hn300000[root@test /]# ulimit -Sn100000[root@test /]# ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 15089max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 100000pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 15089virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 上述示例的设置值均是对公共服务器的配置，具体数据请根据系统实际需要进行设定； 如果上述方法仍然没有解决问题，可以考虑： 1.使用服务的方式启动 nginx 试试；2.加配置内存。 参考文章：http://www.cnblogs.com/sxlfybb/archive/2011/09/15/2177983.html]]></content>
      <categories>
        <category>环境搭建</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ulimit</tag>
        <tag>Ubuntu</tag>
        <tag>内存不足</tag>
        <tag>open files</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 Git 实现版本回退]]></title>
    <url>%2F20171107-git-revert-reset.html</url>
    <content type="text"><![CDATA[使用 Git 进行版本管理时，肯定不只做提交，有时候也会需要回退修改，并且在回退的基础上进行重新提交，这时候有几个常用的命令就需要用到了，下面分别做介绍。 查看提交日志首先，我们查看当前提交记录的命令： 123456789101112$ git logcommit bfee9d6618bc1deae52ac4a7942b96990bbfe661 (HEAD -&gt; master, origin/master, origin/HEAD)Author: sylan215 &lt;sylan215@sylan215.com&gt;Date: Thu Oct 19 15:19:30 2017 +0800 dddcommit fbb28efb4e156031704abbf015b12c8ef16031c8Author: sylan215 &lt;sylan215@sylan215.com&gt;Date: Thu Oct 19 15:15:26 2017 +0800 revert 如果 log 太多，可以加上参数 --pretty=oneline 使用： 123456$ git log --pretty=onelinebfee9d6618bc1deae52ac4a7942b96990bbfe661 (HEAD -&gt; master, origin/master, origin/HEAD) dddfbb28efb4e156031704abbf015b12c8ef16031c8 revertca0e36b485a3de75e6e11064aecc22ce100652dd new line45dcf1bc797a773ca3dee07fc795ef986d10c346 t5e29356aa7aea31e7e6bce302abbc2259324d806 test 查看命令执行记录查看本机命令的执行记录： 123456789$ git reflogbfee9d6 (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@&#123;0&#125;: reset: moving to bfee9d6618bc1deae52ac4a7942b96990bbfe661bfee9d6 (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@&#123;1&#125;: commit: dddfbb28ef HEAD@&#123;2&#125;: reset: moving to fbb28efb4e156031704abbf015b12c8ef16031c8fbb28ef HEAD@&#123;3&#125;: reset: moving to fbb28efb4e156031704abbf015b12c8ef16031c8fbb28ef HEAD@&#123;4&#125;: commit: revertca0e36b HEAD@&#123;5&#125;: reset: moving to ca0e36b485a3de75e6e11064aecc22ce100652ddca0e36b HEAD@&#123;6&#125;: commit: new line45dcf1b HEAD@&#123;7&#125;: reset: moving to 45dcf1 使用 reset 进行回退我们可以通过上述两种方式查看之前的记录，并找到要回退的版本，回退的版本有两种表示方法，一个是 commit id，就是那一串字符，一种是相对 HEAD 的序号，看下命令： 12345$ git reset --hard HEAD^^HEAD is now at ca0e36b new line$ git reset --har bfee9dHEAD is now at bfee9d6 ddd 我们先使用 HEAD^^ 回退了两个版本，然后又使用 bfee9d 这个 commit id 回到了最新版本，注意 HEAD 方式只能回退到旧版本，没法往新版本前进， commit id 的方式可以回退到任意有效 id 的版本，至于怎么查看版本对应的 id 请看最开始介绍的 git log 和 git reflog 命令。 这个命令我们还可变相达成丢弃目前所有修改的效果，直接运行 git reset --hard HEAD 就行。 回退版本后，我们重新进行修改，并提交，会发现有如下报错： 1234567891011121314$ git add .$ git commit -am &quot;test reset&quot;[master 88b1dc8] test reset 1 file changed, 1 insertion(+), 1 deletion(-)$ git pushTo 192.168.252.130:/srv/myfiles.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to &apos;git@192.168.252.130:/srv/myfiles.git&apos;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 解决方法是使用命令 git push -f 解决： 1234567$ git push -fCounting objects: 3, done.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 286 bytes | 286.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To 192.168.252.130:/srv/myfiles.git + bfee9d6...88b1dc8 master -&gt; master (forced update) 注意：git push -f 是强制提交的意思，如果和 reset 结合使用，就会把最新版本到 reset 到的版本之间的所有 commit 全部抹掉了，这在多人协作时，要特别注意。 具体我们通过命令后 git long --pretty=oneline 看得更直观： 12345$ git log --pretty=oneline88b1dc8cb7228f7d1fe14d510a62201a9d584118 (HEAD -&gt; master, origin/master, origin/HEAD) test resetca0e36b485a3de75e6e11064aecc22ce100652dd new line45dcf1bc797a773ca3dee07fc795ef986d10c346 t5e29356aa7aea31e7e6bce302abbc2259324d806 test 和最上面那一次的输出对比，commit id ca0e36b485a3de75e6e11064aecc22ce100652dd 之后的两个提交 id 都被回退了(fbb28efb4e156031704abbf015b12c8ef16031c8 和 bfee9d6618bc1deae52ac4a7942b96990bbfe661)。 另一种温柔的回退方式使用 reset 是直接抹杀掉 commit 的方式，另外还有一种真正的「回退」命令，就是 revert，它的效果时，在当前版本基础上，删掉要回退版本的修改内容后新建一次提交。我们看看效果： 123456789101112$ git log --pretty=oneline9eecd39b8e6a2109c3678c42dc034db2190840f6 (HEAD -&gt; master, origin/master, origin/HEAD) changee4f5e6920c22b748d765824e0be21015332fafa4 init$ git revert 9eec[master f7c9eb4] Revert &quot;change&quot; 1 file changed, 1 insertion(+), 2 deletions(-)$ git log --pretty=onelinef7c9eb4120d368915a6e5491bf85dc5cd87a424f (HEAD -&gt; master) Revert &quot;change&quot;9eecd39b8e6a2109c3678c42dc034db2190840f6 (origin/master, origin/HEAD) changee4f5e6920c22b748d765824e0be21015332fafa4 init 我们在最新版本的基础上，把最后一次提交的修改给回退了，同时用回退后版本生成了一次提交，并生成了新的 commit id，这样所有的操作 log 均得到了正确的保留。 注意：命令 revert 是指回退指定版本的修改内容，而不是指指定版本到当前版本的所有内容，所以如果给定的 commit id 不是当前版本的最新 commit id，那么就会报错： 12345678910111213141516171819202122232425262728$ git log --pretty=oneline45734f3dc12f45e78504bd0fb52ba334c0ae2c9f (HEAD -&gt; master, origin/master, origin/HEAD) test7c82b777a40dfb24fc1bba404be0daa3b3923a95 test revertf7c9eb4120d368915a6e5491bf85dc5cd87a424f Revert &quot;change&quot;9eecd39b8e6a2109c3678c42dc034db2190840f6 changee4f5e6920c22b748d765824e0be21015332fafa4 init$ git revert 7c82berror: could not revert 7c82b77... test reverthint: after resolving the conflicts, mark the corrected pathshint: with &apos;git add &lt;paths&gt;&apos; or &apos;git rm &lt;paths&gt;&apos;hint: and commit the result with &apos;git commit&apos;$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.You are currently reverting commit 7c82b77. (fix conflicts and run &quot;git revert --continue&quot;) (use &quot;git revert --abort&quot; to cancel the revert operation)Unmerged paths: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: test2.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 如果上图，我们跳过了 45734 的修改，想只回退 7c82b 的修改，这时候就提示冲突了，这时候要么手工修改冲突，要么取消 revert 后，一次指定多个 revert id 来实现，下面是一次使用多个 revert id 进行实现： 1234567891011121314151617181920212223$ git revert --abort$ git log --pretty=oneline45734f3dc12f45e78504bd0fb52ba334c0ae2c9f (HEAD -&gt; master, origin/master, origin/HEAD) test7c82b777a40dfb24fc1bba404be0daa3b3923a95 test revertf7c9eb4120d368915a6e5491bf85dc5cd87a424f Revert &quot;change&quot;9eecd39b8e6a2109c3678c42dc034db2190840f6 changee4f5e6920c22b748d765824e0be21015332fafa4 init$ git revert 45734 7c82b[master 8140eb0] Revert &quot;test&quot; 1 file changed, 1 insertion(+), 3 deletions(-)[master 191816d] Revert &quot;test revert&quot; 1 file changed, 1 insertion(+), 2 deletions(-)$ git log --pretty=oneline191816d84c02a4ba591d3739739ddd0df114d7f1 (HEAD -&gt; master) Revert &quot;test revert&quot;8140eb0f69493f1a6306b0e92822f07c049a7a50 Revert &quot;test&quot;45734f3dc12f45e78504bd0fb52ba334c0ae2c9f (origin/master, origin/HEAD) test7c82b777a40dfb24fc1bba404be0daa3b3923a95 test revertf7c9eb4120d368915a6e5491bf85dc5cd87a424f Revert &quot;change&quot;9eecd39b8e6a2109c3678c42dc034db2190840f6 changee4f5e6920c22b748d765824e0be21015332fafa4 init 这时候如果我们查看文件，会发现 45734 和 7c82b 的内容都被回退了，并新生成了两次的 commit(每个 commit id 的回退会单独生成一条记录)。 特别说明一下，为了保证 revert 的效果，建议每次提交修改的时候，尽量减少非耦合文件的一起提交，分批提交可以更利于以后的 revert。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>revert</tag>
        <tag>reset</tag>
        <tag>回退</tag>
        <tag>回滚</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 VM 虚拟机端口映射实现数据转发]]></title>
    <url>%2F20171104-vm-nat.html</url>
    <content type="text"><![CDATA[随着虚拟化技术的应用，很多环境配置都是在虚拟机中进行的，比如前几天我搭建的 Git 服务器，就是在一个物理机的虚拟机上搭建的，一方面可以做环境隔离，另一方面也方便管理，但是这样会带来另一个新的问题：网络访问。 我的多个物理机的网段是相通的，但是虚拟机和其所在物理机使用的是 NAT 模式，所以虚拟机和非其所在的物理机没法直接连通，可以使用如下命令确认下： 12&gt; telnet 192.168.252.129 22正在连接192.168.252.129...无法打开到主机的连接。 在端口 22: 连接失败 下面要介绍的就是如果如何通过 VMware 自身提供的端口转发机制来实现通讯(多谢珂仔的技术支持)。 环境物理机：10.13.11.12物理机：10.13.11.13虚拟机 IP：搭建在 10.13.11.12 上，IP 为 192.168.252.129虚拟机：VMware 14 开始设置查看虚拟机 IP 需要先查看当前的虚拟机 IP，因为后面映射的时候，需要填写 IP 和端口信息： 设置入口 通过 菜单 -&gt; 编辑 -&gt; 虚拟网络编辑器 入口打开设置界面： 提权 我当前使用的是 Windows 7 系统，如果当前用户不是系统的那种 administrator 并且系统开启了 UAC 的话，需要先进行操作提权，才能进行设置，提权操作如下： NAT 设置入口 提权成功后，需要选择当前虚拟机对应的网络，然后点击「NAT 设置」进入详细设置界面： 添加端口转发 在打开的「NAT 设置」界面，点击「添加」来添加对应的转发端口信息： 设置映射 在弹出的对话框，填入物理机的映射端口，注意不能填已经被占用的端口，然后填写虚拟机的 IP 和要转发的端口，比如我要转发的是 git 默认的 ssh 端口，所以填的 22： 确认连接 填写完成后，一路确定下去，直到完成，然后可以在另一台物理机上验证连通性了： 1&gt; telnet 10.13.11.12 10001 确认是可以访问的，这时候在 ssh 配置文件 config 中配置了上述配置后，使用 git 也确认是可以连接到虚拟机的 git 服务器的。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>虚拟机</tag>
        <tag>映射</tag>
        <tag>访问</tag>
        <tag>转发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我和 360 不得不说的事]]></title>
    <url>%2Fi-am-in-360.html</url>
    <content type="text"><![CDATA[今天是「360感恩用户节」，我也记录下自己作为 360 用户的一些足迹吧。 话说上大学时，我是一个标准的裸奔用户(不是人裸奔，是电脑裸奔哦)，对任何杀软都嗤之以鼻，我相信能保证自己访问网址的正确性，能在鱼目混珠、暗链超多的页面中找到自己需要的正确入口，能成功的避过多种恶意插件的捆绑安装，能够准确的找到顽固软件的卸载入口。 另一个方面的原因是早期杀软都需要购买，对当时的我这个穷学生来说，肯定不舍得去掏钱了，找 Key 又太麻烦，所以就自己用的时候小心点裸奔得了(在当时，能控制住自己的冲动和行为，还是相对安全的，现在已经不行了)。 虽然不安装杀软，但是有时候电脑异常，我也有扫毒的需求，当时唯一一个让我十分钟情的工具，就是 3721 的在线扫毒，现在大家一提到 3721 就是它的浏览器插件和中文助手，可是这两个我都不用，我只用它的在线扫毒，记忆中那个功能特别好用，只是在突然的某一天，那个页面就消失了、消失了、消失了，之后也没见人有提起，好吧，看来我属于特殊的用户群体吧。 不装杀软的习惯，在我入职卡巴斯基后，依然没有得到改观，当时是每个正式员工都有发正版 Key 的，就这也没有动摇我裸奔的决心。 这个情况应该是在我入职 360 半年后开始有改观的。一方面是公司倡导的「用户至上」，让我们在项目过程中就站在用户角度去考虑问题，另一方面是，只有自己在真实场景中使用了，才能发现那些非刻意关注到的体验问题。 至今为之，我还一直保持着每天安装最新版，并时常跑一遍 ID 化常规任务的习惯，我的 ID 化等级已经领先 99.83% 的用户了哈。 好了，既然说是用户节，那我就从员工角度说两个「用户至上」的例子吧。 首先说一下今年 5.12 号爆发的永恒之蓝，在收到应急响应通知后，我们立马进入紧急待命状态。 当时有 4 个小组分别从不同方面对问题进行跟进处理，从发现、修复(多种修复方案)到恢复，覆盖了各种不同用户的需要。 只用了 1 天时间，我们就完成了紧急修复工具的方案制定、落实和上线，并且在随后的周末和几个昼夜里，都一直紧跟病毒变种进行了多个版本的迭代更新。 其实针对已经安装了卫士的用户来说，一直保持安装推荐补丁，那就不会有问题，而对于不打补丁的用户，我们的防御功能也是生效的，本次主要是为了挽救没有安装卫士的用户。 说这个事情是想说明什么呢？是的，用户至上。所有的网民都是我们的用户。 保护网民的上网安全，已经成了我们的使命，成了每一个 360 人的使命，所以在出现危害网民安全的时候，大家都可以义无反顾的上前线，用实际行动真真切切的体现为用户着想。 再说第二个事情。 这是个小事。就是上周末带闺女去早教中心，在她们上课的间隙，去玩了下中心的公用电脑，一看不知道，看了后就顺手发现了两个小问题。 回来同步信息给大家后，大家都积极协助定位，并很快确定问题原因，也及时进行了修复，虽然都不是什么紧急重要的地方。 这个事想说明什么呢？之前老周说过一件事，就是他不管到了哪，都喜欢看看别人电脑装没装 360，没有装就极力给推荐。 所以我们很多人现在也都养成了这个习惯，看电脑先看右下角有没有卫士图标。有时到打印店，也一定看看用的是不是 360 U 盘小助手的，是的就会有兴奋感，不是则会有些许失落，然后会侧面打听下原因，回来好优化改进。 上面举的例子都是身边很小很平常的点，其实工作中类似的还有很多，但不管什么事情，什么形式，大家都秉承的是「用户至上」，从这次的「感恩用户节」也能体现，用户是我们做所有事情的根本和出发点。 最后，用我们 B 座北大厅进门的标语结个尾： 「为人民服务」。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>360</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当你控制不住自己时你在想什么]]></title>
    <url>%2Fzizhili.html</url>
    <content type="text"><![CDATA[花费了近一个月的早起，终于把《自制力》看完了，一开始真没想到这个话题可以写十八章之多。 我是每天读一个章节，所以总感觉整本书没有连贯串通起来，各个章节各自太独立了，还好今天专门抽时间做了下串联，下面算是串联后的总结吧。 其实所有十八章，汇总成主题后都可以通过第一章和第十三章的总结来进行说明： 首先要确定目标，然后确定达成目标的方向，最后一定要落实行动。其中，确定目标和方向过程中，都会面临选择，这时候要保持理性，做出正确的选择。 根据这个说明，我把所有十八章重新按照 目标、方向、行动 做了划分，重新划分后的导图如下： 下面分别从这三大方面进行说明。 目标：自我认知不足从宏观上来讲，做任何事情都应该是目标明确的。 小事的话，比如我写这篇文章的目的是为了完成对《自制力》的读后总结，放大一点说，写读后总结是为了锻炼自己的理解和总结能力，并通过公众号进行呈现。 大事的话，比如我们这一生的目标是为了享乐？在某一领域成为佼佼者？还是有其他更崇高的目标，等等。 这些都算作目标。 生活和工作都是由许许多多、各种各样、大大小小的目标组成的，而把这所有目标汇总后就是我们人生的目标。 反过来说，我们只有确定了人生的目标，才能保证分解后的小目标都是为了大目标服务的，否则就会陷于迷茫和无力感了。 书中总结了诸多影响目标确立的原因，其中汇总表述就是「自我认知不足」，什么意思呢？就是因为对自身能力、定位、喜好不清楚，从而导致目标定的大了、小了、错了等。 目标有问题了，方向和行动再给力，最后也只能是竹篮打水一场空了。 那么有没有办法解决这个问题呢？书上也给了相关的建议： 第五课-自责和自我设障：就是自信心不足，这时一定要找到自己自信心不足的具体原因，并针对性的从源头解决；第六课-把欲望装进笼子：说的是虚假的欲望的问题，虚假的欲望和真实的目标总是形影相伴，当出现虚假欲望的时候，要理性的进行区分；第八课-驱除内心的无力感：一句话「积极向上，保持正能量」；第十一课-不要欺骗自己：「看清现实，遵守承诺」；第十三课-做出重要的选择：保持尽量少的选择，选择越多反而会让自己更迷茫；第十六课-我可以：制定切合实际的目标，然后 Just do it!其实有点废话，关键问题是什么样的目标才是切合实际的目标；第十七课-发现自己的人生使命：这一课也是大道理，行行行，你说的都是对的；第十八课-有多久没有成就感了：做好长期坚持的思想准备，从小事做起，并坚持下去。 其实大部分人，包括我自己在内，都还局限在这个问题上长期不能自拔。 比如我自己维护的公众号，形式和时间都不固定，想到哪写到哪，有时间更新，没时间就不管。但是我认识的一位老师，能够长期保持公众号日更，而且一直保持对文章进行点评的形式，从未间断，这是对自我认知清晰的事实体现了，给个大大的赞。 方向：思路不正确目标如果确定了，接下来就是行动了，而方向就是我们的行动指南。 比方说我要学 Python 了，我定了月目标是熟悉 Python 相关的所有基础知识，方向是怎么实现这个目标，我可以读书、看在线教程、看在线视频、上网课、培训班、做基础课习题等等，看，这一下就列出了这么多，到底哪个才是适合自己的正确的方向呢？ 这个问题其实网上也经常被问到，也有很多中肯的回答了，目前本书上给的建议如下： 第四课-集中注意力，让思维清晰起来：制定目标和方向，以及落实的过程中一定要保持注意力的集中，全神贯注的思考，才能让效果事半功倍第九课-掌握时间：方向和做事情的优先级也是有关系的，比方上面的一系列方式，也可以按优先级不同来组合使用第十二课-停止批评：保持积极的心态，在碰到挫折甚至错误时，能够继续保持方向的正确性并坚持下去第十四课-潜能控制：要始终保持能够达成目标的潜意识，并合理利用潜意识的潜在力量 另外，一定要记得过程中根据实际情况灵活变通，不要一条道走到黑。 这一点目前对我自己来说，主要的问题还是如何长期的坚持下去。 行动：自我控制不足行动其实不能算单独的一个阶段，之所以单独拿出来说，是因为没有行动的话，目标和方向都是扯淡，而目标和方向又是在行动过程中不断完善、优化和改进的。也就是说，目标和方向最终都需要落实到行动上，也只有按照正确的方向行动了才能达成最终目标。 那么这里讲的行动，确实所有环节中最容易出问题的地方。毕竟目标和方向都只是空泛的，我可以每天都定一个目标和方向，但行动却不是，它需要时间，最重要的是需要在达成目标前的坚持。 坚持，是一件最容易，又是一件最最困难的事情。 一切没有坚持下来的原因，都被归纳为「自我控制不足」，本书针对这个问题的建议是： 第二课-走出失控的怪圈：记住，只有你可以控制你自己，包括你的意识、神经反应和肉体；第三课-管理你的情绪：情绪是意识的一种体现，请保持乐观、积极向上的情绪；第七课-解决拖延症：噢，拖延症，想说恨你不容易，啥也别说，就一个字-干；第十课-压力从何而来：适当给自己一些压力，可以让自己保持行动力；第十五课-训练你的意志力：哟，这个就是所谓的自制力了，如果意志力足够强大，就不会存在自我控制不足的问题了； 看看自己是不是存在这些问题吧，对于我来说，意志力这个真的需要锻炼了，不太容易能控制住诱惑，比如说游戏。 小结在读书的过程中，我一直在想，书名为啥叫《自制力》，和我当初理解的自制力的范畴太不一样了，我只是局限在最后关于行动方面的自制(克制)上面了，而本书说的自制力确是贯穿在目标、方向和行动的各个方面，是的，从宏观上讲，各个方面也确实都需要保持自制，才能有更清晰的自我认知、才能保持思路清理、才能保持良好的自我控制。 书看完了，感慨也发完了，下面得赶紧落实效果去了。 附：完整导图下载地址 点我下载]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>自制力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用七牛接口实现图片和文件一键上传]]></title>
    <url>%2Fupload-to-qiniu.html</url>
    <content type="text"><![CDATA[本文主要介绍使用七牛提供的接口把七牛云作为图床，用 Python 实现图片上传和文件上传的脚本实现，可以支持按文件夹批量上传。 搭建过网站的同学，一定都涉及到图片上传和文件上传的问题，最近为了弄图片资源接触了一下云存储，还挺挺好用。 之前如果我们把图片资源存储到本机服务器，那就每次写文章的时候都需要准备一堆的图片，并且要上传到对应的相对目录上去，如果用了云存储(不限七牛)，好处就是需要的资源直接上传，然后生成一个链接来使用就行了，Markdown 语法对链接的支持也很好，恩，可以搞一下。 不过，又有了新问题，就是是用云存储，得先经过登录-&gt;打开对象存储-&gt;打开内容管理-&gt;上传，然后填入上传后的相对目录，并手动选择本地文件，是不是很麻烦？ 所以本次是提供了一个一键上传资源的脚本(仅针对七牛云)，实现的效果就是，输入项目目录和文件本地地址后，自动上传所有文件到云端，并生成可使用 URL。 来，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-import osimport sysfrom qiniu import Auth, put_fileif 3 != len(sys.argv): print('[Usage] %s [dir_set] [filepath]' % os.path.basename(sys.argv[0])) sys.exit(0)else: # dir_set 的格式为 image/upload-qiniu/ ，注意末尾带反斜杠/ dir_set = sys.argv[1] file_path = sys.argv[2]# 个人中心-&gt;密匙管理-&gt;AKaccess_key = '你的AccessKey'# 个人中心-&gt;密匙管理-&gt;SKsecret_key = '你的SecretKey'# 七牛空间名bucket_name = '你的存储空间名'qiniu_auth = Auth(access_key, secret_key)def upload_qiniu(input_path): #upload single file to qiniu filename = os.path.basename(input_path) key = '%s%s' % (dir_set, filename) token = qiniu_auth.upload_token(bucket_name, key) ret, info = put_file(token, key, input_path, check_crc=True) if ret and ret['key'] == key: print('%s done' % ('http://www.sylan215.com/' + dir_set + filename)) else: print('%s error' % ('http://www.sylan215.com/' + dir_set + filename))def upload_all_files(input_path): if os.path.isfile(input_path): upload_qiniu(input_path) elif os.path.isdir(input_path): dirlist = os.walk(input_path) for root, dirs, files in dirlist: for filename in files: upload_qiniu(os.path.join(root, filename)) else: print('Please input the exists file path!')if __name__ == "__main__": upload_all_files(file_path) 使用说明1. 请先安装 qiniu 的依赖库：1python -m pip install qiniu 2. 修改绑定域名修改代码中的 http://www.sylan215.com 为自己在七牛云存储绑定的域名 3. 带两个参数执行脚本第一个参数是上传后的目录，第二个参数是文件在本地的地址，支持文件夹。 其中第一个参数的目录格式为：image/test/。 比如如下的命令: 1upload_to_qiniu.py image/test/ d:\test.png 运行后，上传后的文件地址就类似：http://www.sylan215.com/image/test/test.png PS：已使用 Python2.7 和 Python3.4 亲测有效，其他 Python 版本如果有异常，请反馈。 更详细的说明请跳转到项目地址：https://github.com/sylan215/upload-to-qiniu，欢迎大家 star，并一起丰富这个脚本的功能。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>七牛图片上传</tag>
        <tag>七牛文件上传</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天，一个共事 4 年的同事离职了]]></title>
    <url>%2Fjust-for-remind.html</url>
    <content type="text"><![CDATA[菁菁提离职时，我其实并没感到很意外，另一个和她一样没有转岗成功的同事已经提过离职了。 但是前两个月她提转岗时，我倒是挺意外，如果从稳定度来讲，我甚至觉得她应该是我们团队最稳定的一个了。 作为 Leader，没有早点发现导致这个结果的苗头，我其实是有责任的。 菁菁从 2013 年 6 月份入职，到现在已经 4 年有余，入职没多久，就表现出不俗的专注力，对事情的分析、定位、跟进都很尽责，对经手的项目也都能打破沙锅问到底，深入细节，交给她的项目质量都能得到很好的保障。 如果从技术上来讲，目前工作需要的一些技能和方法她都可以进行熟练的应用了，和她沟通过几次之后，决定后续往管理方向培养，她也是同意的，而且她提出的一些团队改进的建议也都比较中肯，所以希望能有机会让她自己进行实践，并在这方面有所提升。 但是这次离职，她并没有继续往管理岗上进行深入，而且还换了个专业。 现在回头看，当初的出发点可能已经错了，日积月累，也就造成了目前的结局，下面我简单列一下自己的总结。 1. 性格菁菁是属于偏静一点的性格，就算动起来也是一股子的技术气息，这样的性格更适合做钻研、攻坚一类的任务。 然而目前因为各种原因，我们都是优先考虑技术好的人往管理岗进行培养，毕竟技术上好了更容易服人，也更能在关键时刻顶上去，那么这样问题就来了，技术好、又有管理意识的人毕竟是太少了。 从这点上来说，当初的决定其实已经错了，性格对一个人的影响是不可低估的，毕竟都有人提出过「性格决定命运」的论调，对于目前的我们来说，遵从性格就是遵从内心，而逆行的阻力是巨大的。 所以后续在人员培养过程中，需要把「性格」作为其中一个关注点了。 2. 虚假的希望前面有提到过说，往管理方向培养，菁菁和我是达成共识的，那最后为啥又变了呢？ 这第二点的原因我总结为「虚假的希望」。 从菁菁的角度看，她也明白自己在管理方面的欠缺，所以有改进这方面能力的欲望，这也是她自己的「希望」，之所以变成了「虚假的」，因为那真的仅仅是「希望」，这个希望没有让自己有冲动的感觉，或者说心流的感觉，所以那只是附属的希望，可以顺便达成的希望，也就是「虚假的希望」。 从我的角度看，我「希望」菁菁能在管理方面，特别是带人方面有长足的进步，这样可以把她的优势进行有效的复制，一方面让其他人在技术能力上得到成长，另一方面菁菁的管理能力也能有同步成长，双赢的效果还是挺让人期待的。之所以变成了「虚假的」，主要是因为那是我的希望，而这个希望又不是由我来达成，并且没有充分考虑到达成过程中的风险。 所以后续在人员培养过程中，需要区分哪些是「虚假的希望」。 3. 过程中的指导接上一点。虽然希望不是由我达成，但是作为 leader，我应该有监督指导的义务。而这个也是本次被忽视的。 一方面，菁菁一直以来在项目上表现的专注，确实让人放心，她已经具有自己发现并解决问题的能力；另一方面，和她的多次沟通中，菁菁表现出来的对管理方面的一些理解和建议都很符合实际，目前缺的就是怎么给做下去，所以我就给予了充分的自由。 目前看来，在没有成功的事实体现前，过程中的监督指导还是必不可少的。 菁菁在休假前，一直能保持尽职尽责，甚至其他人一点都没看出来她有离职的迹象，甚至今天走之前，还给我写了一个要转正的新人的评价，这份专注必须给点赞。同时菁菁也没有提到因为部门、团队或人员安排的原因导致离职，这点还是让人有点欣慰。 知道菁菁要入职的公司后，我也给联系了一个早前跳槽过去的同事，希望在新公司相互有个照应，能做的也只有这些了。 从个人角度来说，如果我们团队的人在离职后能找到更好更大的平台，发挥自己更大的潜力的话，我是衷心的祝福她们的，毕竟我体会过那种幸福的感觉。 祝，好运，珍重！]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>离职</tag>
        <tag>性格</tag>
        <tag>虚假的希望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next 主题下点击后出现红心效果]]></title>
    <url>%2Fhexo-next-hongxin.html</url>
    <content type="text"><![CDATA[本文主要介绍通过 javascript 脚本实现鼠标点击后，有小红心冒出的特效，下面是详细操作步骤。 在 hexo\themes\next\source\js\src\ 目录下新增文件 love.js，文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546!function(e, t, a) &#123; function n() &#123; c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = "left:" + d[e].x + "px;top:" + d[e].y + "px;opacity:" + d[e].alpha + ";transform:scale(" + d[e].scale + "," + d[e].scale + ") rotate(45deg);background:" + d[e].color + ";z-index:99999"); requestAnimationFrame(r) &#125; function o() &#123; var t = "function" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function(e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement("div"); a.className = "heart", d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement("style"); a.type = "text/css"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName("head")[0].appendChild(a) &#125; function s() &#123; return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")" &#125; var d = []; e.requestAnimationFrame = function() &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n()&#125;(window, document); 然后在文件 hexo\themes\next\layout\_layout.swing 底部的 &lt;/body&gt; 标签上一行增加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 好了，执行命令 hexo s --debug 看看效果吧。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>鼠标点击</tag>
        <tag>红心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个版本的 Python 在使用中的灵活切换]]></title>
    <url>%2Fpython-config-build.html</url>
    <content type="text"><![CDATA[今天我们来说说在 windows 系统上如果有多版本的 python 并存时，如何优雅的进行灵活切换。 虽然 Python3 已经出来很久了，虽然 Python2 即将成为历史了，但是因为历史原因，依然有很多公司的老项目继续在使用着 Python2 版本(切换成本太高)，所以大多数开发者机器上 Python2 和 Python3 都是并存的，本文主要说明这种情况下如何便捷的在 Python2 和 Python3 之间进行切换。 先说明下，本次我们不介绍 virtualenv，也不介绍 pipenv，因为这两个都是为了大型的 Python 工程做准备的，之后会单独文字进行说明。 本次是不借助外部工具，来实现快捷切换。其实也可以说是利用系统环境变量的逻辑来实现目的。 本次环境以 Windows 为例： 系统： Windows 7 x64Python 版本：Python3.4 和 Python 2.7 安装首先安装好 Python3.4 和 Python2.7，安装包可以在这个地方进行下载：点击跳转。 设置环境变量然后分别把对应版本的安装路径加入到系统环境变量中去： 新起一个 cmd 窗口验证下添加后的效果： 123C:\Users&gt;pathPATH=C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files\Git\cmd;C:\Python34;C:\Python27; 这时候我们直接在 cmd 输入 python，已经可以被识别了，但是识别的总是路径在环境变量中排前面的那个版本的 Python，比如目前从上图看 Python3.4 是排前面的，实际验证下看看： 12345C:\Users&gt;pythonPython 3.4.4 (v3.4.4:737efcadf5a6, Dec 20 2015, 20:20:57) [MSC v.1600 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 重命名主程序然后我们分别把两个版本的 Python 主程序 exe 改下名，3.4 版本的改名为 python34.exe，2.7 版本的改名为 python27.exe： 再分别运行 python34 和 python27 试试： 1234567891011C:\Users&gt;python34Python 3.4.4 (v3.4.4:737efcadf5a6, Dec 20 2015, 20:20:57) [MSC v.1600 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;C:\Users&gt;python27Python 2.7.14 (v2.7.14:84471935ed, Sep 16 2017, 20:19:30) [MSC v.1500 32 bit (Intel)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 从上图可以看出，我们已经可以实现分别运行指定版本的效果了，如果执行脚本的话直接 python34 test.py 或者 python27 test.py 就行了。 但是每次执行脚本都加前缀是不是很累，如果有一个版本是我们常用的话，也可以通过修改文件后缀关联程序来实现默认关联，再需要特殊版本的时候再加上前缀就行，不过保险起见，还是一直带着吧。 补充说明补充说明下，其实网上也有网友提供了其他两种方法： 使用 Python 自带的 py -2 和 py -3 命令；另一种和我上面说的类似，但是只重命名了其中一个版本的执行文件名； 如果机器只安装了两个版本的 Python，这几个方法确实是都可以解决的，但是因为我需要部分脚本支持 Windows XP (Python3.5 以后就不支持 XP 了)，所以安装了 Python2.7、Python3.4 和 Python3.6 共三个版本的 Python，这样的话就只能把全部主程序文件都重命名了，而且这样解决的问题更彻底，一劳永逸。 再补充说明下，如果要针对不同版本的 Python 调用 pip，命令后如下(请把 requests 换成自己需要的包名)： 123python27 -m pip install requestspython34 -m pip install requestspython36 -m pip install requests 这样安装的依赖库就是在各个版本之间相互独立的。 好了，赶紧动手试试吧。当然，如果您有更好的建议，欢迎留言讨论。]]></content>
      <categories>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>python多版本共存</tag>
        <tag>windows python多版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何删除 Launchpad 中的无用图标]]></title>
    <url>%2Frestore-launchpad.html</url>
    <content type="text"><![CDATA[最近在 Mac 上使用 Atom，发现 Atom 并不是安装上去的，下载后解压直接就是个 app 了，所以我手动给拖拽到 Launchpad 了。 今天突然发现有个新版本，所以重新下载了一个，双击运行后，发现两个并不是同一个来源，所以就把老的源文件给删掉了，但是老版本对应的 Launchpad 图标还在，搞不懂。 所以又手动拖了一遍新版本 Atom 到 Launchpad，这下可好，竟然有两个 Atom 图标了，尝试使用长按后点叉叉的方式给删掉，却发现这俩图标上面竟然没有叉叉，郁闷了，人肉到网上搜了几个方案都不是特别实用，终于找到一个亲测可用的赶紧记录备案。 步骤： 在 Docker -&gt; 系统偏好设置 中打开终端 终端中输入：defaults write com.apple.dock ResetLaunchPad -bool true 后回车 终端中输入：killall Dock 后回车 重新打开 Docker 查看效果，一切都被还原，赞 注意：这种方式会还原自己自定义的一切设置，比如图标分类等，请按需取用]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Launchpad</tag>
        <tag>恢复</tag>
        <tag>删除图标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心流]]></title>
    <url>%2Fheart-flow.html</url>
    <content type="text"><![CDATA[最近在看《驱动力》这本书，其中有提到「心流」这个词，只是从描述来说，有点太抽象，不过刚好最近感受了几次「心流」的感觉，所以记录一下。先说下概念，心流主要是指一种自动的、非刻意的、高度集中、全情投入并享受其中的的忘我精神状态。 我自己感受到的「心流」状态是最近在学习 python 编程，通过编写一些工作中需要用到的工具的过程。 这个过程中的带来的特殊感受有： 自己制定目标，自己规划目标，并自觉的持续达成；达成目标过程中的所有问题都有耐心并积极的寻求问题的解决办法；时间过得特别快，甚至愿意花费自己的休息时间来保证目标达成；持续的改进动力，且没有对回报的渴求，更加享受这个过程； 其中有三次典型的心流峰值，下面分别说明。 第一次是解决一个编码的问题。这是一个工具的需求，需求是使用字符串形式读取一个 PE 文件，然后暴力搜索其中的字符串。 同样的实现语句，在 Python2 中的输出是正确的，但是在 Python3 中的输出却不正确，检查发现和默认编码有关系，Python2 默认使用的 ascii，而 Python3 默认使用的是 utf-8，如果使用记事本打开的话，默认也是使用 ascii，所以和 Python2 的效果一样。 为了让实现效果一致，在 Python3 的实现中我显式设置 encoding 为 gbk 了： 1f = open(readFile, 'r', encoding='gbk') 结果就是这个语句报错了：1'gbk' codec can't decode byte 0x90 in position 2: illegal multibyte sequence 也就是这个错误导致我纠结了很久，花费了不少的时间，甚至有一段时间都搁置了，最终我把问题提交到了 stackoverflow，同时继续查资料，也就是提交问题后不久，就在 python 官方文档中找到了解决方案： 12345The errors parameter is the same as the parameter of the decode() method butsupports a few more possible handlers. As well as &apos;strict&apos;, &apos;ignore&apos;, and&apos;replace&apos; (which in this case inserts a question mark instead of the unencodable character), there is also &apos;xmlcharrefreplace&apos; (inserts an XML characterreference) and backslashreplace (inserts a \uNNNN escape sequence). 其实还是蛮讽刺的，因为基础没打牢，一个基本的函数实现却耗费了不少的时间，虽然解决问题后，那种兴奋的感觉还是蛮让人激动，不过最大的收获还是发现问题先看官方文档。 上述问题的详细描述可以 看 stackoverflow。 第二次是解决一个打包的问题。因为我的工具会分发给大家使用，但不是每个人的环境都安装了 Python3，或者即使安装了，相关的依赖库也不一定完备，所以我是使用 pyinstaller 进行了打包后再进行分发的，但是因为 pyinstaller 自身的 Bug，让我打包的 exe 总是没法自动提权，网上搜了下，很多人碰到这个问题，但是都没有很完整的解决方案，自己在尝试多次后，都有点要放弃了。 最后突然想起来自己使用的某些工具也是使用了类似的功能，所以问了下这些工具的打包流程，要了打包脚本看了下，突然了恍然大悟了，没有问题的这个是使用的 pyinstaller 提供的另外一个方式而已，只是会稍微麻烦点，需要单独准备资源文件，然后把资源文件进行嵌入，自己拿来改造优化一下，最终实现了预期效果。 这件事给的教训就是，很多问题，一定要站在前人的肩膀上去看问题，这样可以是事半功倍，当然，拿了别人的解决方案也不能仅仅是拿来主义，需要搞明白其中的原理，方便自己举一反三，或者优化改进。 另外，对于自己在过程中付出了努力、时间和精力的问题，最终解决的时候，还是十分令人激动的，我认为这就是「心流」的感觉。 第三次是解决一个父子窗口联动的问题。这次和第一个问题有点类似，就是有一个实现的效果，明明知道可以实现，但就是不知道怎么去写代码实现，或者说不知道方法怎么合理去利用。 我大概描述一下吧：我新建了一个窗口，是在主窗口上点击按钮后弹出的，现在我要在新窗口修改主窗口的内容，但是一直不知道怎么调用主窗口的控件。 和第一个问题类似，我也知道需要利用父类继承的逻辑来达到效果，但就是不知道怎么去写。 在尝试了多种实现方案，在网上看了所有能看到的资料后，最终还是把问题提交到了 stackoverflow，结局和第一个问题类似，在我提交了问题后不久，自己就又找到了问题的解决方案，仅仅是在自己之前的方法中多增加一个初始化字段： 1self.parent = parent 问题是简单的，道路是曲折的，问题解决了，心情是高兴的，留给自己更大的反思还是对于一些基础的巩固一定要加强，只有某一些理论知识丰富了，后面的实践才能更得心应手。 当然，本次主要想说明的是解决问题的兴奋感，不管问题大小，只要是自己觉得有价值的，那么问题带来的不是挫折、不是困难、不是灾难，是兴奋、激动和「心流」的感觉。 上述问题的详细描述可以 看 stackoverflow。 简单做下总结。 发现问题和解决问题的过程是最有意义的，有些问题解决后才发现原来只是某一点没有想到而已，但是在没有想到之前，这就是一个盲点，而解决这个盲点就是这个过程中最大的意义。 比如最后一个问题，其实我之前也尝试过用父类的方法进行传递和调用，但是方法不正确，导致结果也不正确，最后就尝试其他方法，最后却还是兜兜转转转回来了。 另外一点感触就是，基础知识太重要了，有些盲点仅仅是因为太注重实用过程，所以疏于基础的巩固，那么一些很基础的特性可能就不会被想到，那么导致的就是问题解决的复杂度提高了，比如第一个问题的 ignore 参数问题，理论来说，是个函数的基本参数而已，不应该因此耗费太多时间。 最后一点，「问题」不仅仅是「问题」而已，他是一个契机、一个场景、一个过程、一种经历，只有经历了「问题」，才能享受到解决问题的「心流」的感觉。 人生不也是如此？ Enjoy it!]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>驱动力</tag>
        <tag>python</tag>
        <tag>encoding</tag>
        <tag>问题</tag>
        <tag>心流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你在 Ubuntu 上搭建 Git 服务器]]></title>
    <url>%2Fgit-config-on-ubuntu.html</url>
    <content type="text"><![CDATA[最近在写一些脚本，为了保持连续性，就在家也抽空赶进度，所以碰到了代码同步的问题，目前想到的方法有三个： 使用云盘，这个拿来即用，但是因为云盘还存放了其他一些东西，总是实时同步不太妥当；使用 SVN，传统的代码托管工具，一直在用；使用 Git，最新的分布式代码托管工具，据说很强大。 最后决定使用 Git，主要是学习下最新的技术。下面是操作步骤，做记录的同时也给其他同学做个指引： 先说下环境： 服务端： Ubuntu 16.04 x64客户端： Windows7 x64 服务端配置先使用如下命令切到 root 权限进行操作： 1sudo bash 提示输入密码时，输入 root 密码即可。 登录成功后，开始安装 git，命令： 1apt-get install git 提示是否继续时，输入 y 后回车，安装流程继续，并直至安装完成。 接着开始安装 ssh，命令： 1apt-get install openssh-server openssh-client 同样在询问是否继续时，输入 y 后回车，安装会自动完成。 然后我们新建一个 git 专属用户，用户名也叫 git，命令： 1adduser git 新建成功后会提示设置用户密码，请设置一个自己能记住的密码后继续，后续的详细信息可以酌情填写。 下面开始新建 git 仓库，我们选定仓库存放目录为 /srv 下面，仓库名 myfiles.git，所以命令： 1git init --bare /srv/myfiles.git 因为当前用户是 root，为了让后面 git 专用账户能够操作仓库目录，我们需要把仓库目录授权给 git，命令： 1chown -R git:git /srv/myfiles.git/ 客户端操作首先需要下载 Windows 版本的 git，下载地址：点击下载 下载完成后点击安装，并根据提示点击「下一步」，直到安装完成。 在客户端创建一个工作目录，比如我的是 gitdir，在工作目录内右键并点击 「Git Bash Here」。 在弹出的命令后窗口 clone 仓库到本地： 12345678$ git clone git@192.168.252.128:/srv/myfiles.gitCloning into 'myfiles'...The authenticity of host '192.168.252.128 (192.168.252.128)' can't be established.ECDSA key fingerprint is SHA256:zqtjAg+FGfWrT3SCp1Qa2KqhE2UOy3PmudhhrTFlm7A.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.252.128' (ECDSA) to the list of known hosts.git@192.168.252.128's password:warning: You appear to have cloned an empty repository. 注意请把「192.168.252.128」换成自己的服务端 ip，并且在确认时输入的是「yes」，最后输入的是创建 git 用户时候的密码。 为了客户端进行后续的提交操作，我们还需要注明当前机器的用户信息，命令后如下： 12git config --global user.email "you@example.com"git config --global user.name "Your Name" 注册后，commit 的时候会使用这个注册信息来记录操作人信息，然后在使用 git log 时可以看到对应的信息，效果如下图： 123456$ git logcommit ae72bcc89ea8f5d9d3a44f0e00cf35e91a1afce8 (HEAD -&gt; master, origin/master)Author: sylan215 &lt;sylan215@sylan215.com&gt;Date: Wed Oct 18 18:37:41 2017 +0800 测试提交 至此，我们完成整个配置过程。 文件修改并同步到 Git 服务器配置完成后，我们就进入实际使用环节了。 首先我们先修改几个文件，并拷贝到 myfiles 目录下，然后提交到服务端，在 myfiles 下运行提交命令： 123git add .git commit -am "测试提交"git push 带输出的命令行内容： 123456789101112$ git add .$ git commit -am "测试提交"[master (root-commit) ae72bcc] 测试提交 1 file changed, 1 insertion(+) create mode 100644 test.txt$ git pushgit@192.168.252.128's password:Counting objects: 3, done.Writing objects: 100% (3/3), 223 bytes | 223.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To 192.168.252.128:/srv/myfiles.git * [new branch] master -&gt; master 提示输入密码的地方，还是输入的 git 账户的密码。 说明：关于 git 操作的详细命令，请参考 这篇文章 提交成功后，我们在另一台机器上使用命令 git pull 同步最新内容： 1234567891011$ git pullgit@192.168.252.128's password:remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From 192.168.252.128:/srv/myfiles ae72bcc..afad897 master -&gt; origin/masterUpdating ae72bcc..afad897Fast-forward test.txt | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-) 对于多用户的复杂操作，请参考这篇文章 其它配置禁用 git 账户的 shell为了安全考虑，如果需要禁用 git 账户的 shell，可以修改 /etc/passwd 文件： 把其中的 1git:x:1001:1001:git-user,,,:/home/git:/bin/bash 修改为 1git:x:1001:1001:git-user,,,:/home/git:/usr/bin/git-shell 其中 /usr/bin/git-shell 的路径可以通过命令 which git-shell 获得。 使用公匙和私匙实现免密效果上面我们使用的过程中每次都需要输入 git 用户的密码才能和服务端交互，这样会很麻烦，这时候我们可以配置公私匙来实现免密。 首先，需要在客户端生成公私匙： 1ssh-keygen -t rsa 回车后会提示输入私匙的密码，如果要免密就直接回车，否则自定义一个密码(如果自定义了密码，则每次 push 和 pull 时填入的是设置的密码)。 命令执行成功后，会在当前用户目录的.ssh文件夹(Windows 目录是 X:\Users{username}.ssh， Linux 是 /home/{username}/.ssh)生成文件「id_rsa」和「id_rsa.pub」，其中 .pub 文件就是公匙，另一个是私匙。 把文件「id_rsa.pub」拷贝到服务端，并使用如下命令进行设置： 123mkdir /home/git/.sshcp /home/currentuser/Desktop/id_rsa.pub /home/git/.ssh/authorized_keyschown -R git:git /home/git/.ssh 说明，如果 authorized_keys 文件不存在，可以使用 cp 命令，否则请使用 cat 命令追加，比如： 1cat /home/currentuser/Desktop/id_rsa.pub &gt;&gt; /home/git/.ssh/authorized_keys 为了保证配置生效，还需要查看 /etc/ssh/sshd_config 文件中的如下设置是否开启： 1AuthorizedKeysFile %h/.ssh/authorized_keys 是否被注释掉了，如果是，则需要把前面的 # 去掉，并重启 ssh 服务(命令 service ssh restart)。 全部配置完毕后，我们试试效果： 12$ git pullAlready up-to-date. 看，这次没有提示输入密码了吧，免密设置生效。 非 22 端口连接 Git在 .ssh 配置目录现在 config 文件，内容为： 12host ip地址port 端口名 config 配置文件在 Windows 和 Mac 系统的位置为：X:/users/username/.ssh 目录，其中 X 为系统盘， username 为当前登录用户名； 如果是 liunx 系列系统，位置为 /home/username/.ssh 目录，其中 username 为当前登录用户名。]]></content>
      <categories>
        <category>环境搭建</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>环境</tag>
        <tag>git server搭建</tag>
        <tag>ubuntu git server</tag>
        <tag>搭建git lab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底搞懂 Python 编码]]></title>
    <url>%2Fpython-coding.html</url>
    <content type="text"><![CDATA[因为中文的特殊编码，导致 Python2 和 Python3 使用过程中的各种编码问题，如果不清楚其中的关联关系，那么这就一直是个大坑，不是懵逼就还是懵逼，所以就目前碰到的情况彻底梳理下 Python2 和 Python3 中编码的关系和区别，以作备忘。 先说下涉及编码格式的几个地方： 脚本字符编码：就是经常在脚本文件开头看到的 # -*- coding: utf-8 -*-，如果使用 Python2，没有显式声明的话默认使用 ASCII 格式，Python3 默认使用 utf-8 格式； 解释器字符编码：可以通过函数 sys.getdefaultencoding() 查看，Python2 默认是 ASCII，Python3 默认使用 utf-8； 脚本文件存储编码：就是 py 脚本文件本身在物理介质上面的存储格式，通常有 ASCII、GBK、utf-8 等格式。 下面我们把上述编码分别在脚本中进行组合使用后，再使用 Python2.6 和 Python3.4 运行，看看实际都什么效果。 1.默认脚本文件编码 + 文件存储使用 gbk脚本内容： 1234import sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果如下，提示gbk 编码字符 \xd6 非 ASCII 字符： 123&gt; python26 test_gbk.py File "test_gbk.py", line 4SyntaxError: Non-ASCII character '\xd6' in file test_gbk.py on line 4, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details 使用 Python3.4 运行的结果如下，提示gbk 编码字符 \xd6 非 utf-8 字符： 123&gt; python26 test_gbk.py File "test_gbk.py", line 4SyntaxError: Non-UTF-8 code starting with '\xd6' in file test_gbk.py on line 4, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details 结论：默认的 gbk 编码中文，Python2的解释器字符编码(ASCII)和 Python3的解释器字符编码(utf-8)格式都没法识别，因为 ASCII 编码不包含中文，而 utf-8 是 3 字节编码，gbk 是 2 字节编码，所以都识别不了了。 2.脚本文件编码 gbk + 文件存储使用 gbk在刚才的脚本头部显式声明脚本文件编码格式为 gbk： 123456#coding:gbkimport sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果：123&gt; python26 test_gbk.pyascii中文 使用 Python3.4 运行的结果：123&gt; python34 test_gbk.pyutf-8中文 结论：文件使用的 gbk 格式存储，同时显式声明了脚本文件编码为 gbk，Python2 和 Python3 都可以正常处理。 3.脚本文件编码 utf-8 + 文件存储使用 gbk在刚才的脚本头部显式声明脚本文件编码格式为 utf-8： 123456# -*- coding: utf-8 -*-import sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果正常： 123&gt; python26 test_gbk.pyascii中文 使用 Python3.4 运行的结果如下，提示尝试使用 utf-8 解码字符 0xd6 时异常： 123&gt; python34 test_gbk.pyFile "test_gbk.py", line 6SyntaxError: (unicode error) 'utf-8' codec can't decode byte 0xd6 in position 0: invalid continuation byte 结论：文件使用的 gbk 格式存储，同时显式声明了脚本文件编码为 utf-8时，但是 Python2 在 Windows 平台还是使用 gbk 进行输出，所以解析正常，而 Python3 使用 utf-8 所以解析异常。 4.默认脚本文件编码 + 文件存储使用 utf-8去掉之前脚本头部的声明，然后使用 utf-8 格式存储文件(注意，不能在刚才的文件基础上强制修改存储编码，强制转换会出现中文乱码的问题，建议先新建一个 utf-8 格式的文件，然后再输入中文)： 1234import sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果如下，ASCII 也识别不了 utf-8 格式的字符 \xe4： 123&gt; python26 test.py File "test.py", line 4SyntaxError: Non-ASCII character '\xe4' in file test.py on line 4, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details 使用 Python3.4 运行的结果，可以正常识别，因为 Python3 默认使用 utf-8 编码： 123&gt; python34 test.pyutf-8中文 结论：默认的 utf-8 编码中文，Python2 会默认使用 ASCII 读取，所以没法识别，Python3 可以正常识别。 5.脚本文件编码 gbk + 文件存储使用 utf-8脚本头部显式声明脚本文件编码格式为 gbk，同时使用 utf-8 格式存储文件： 12345#coding:gbkimport sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果如下，使用 gbk 根本读取不了 utf-8 格式任何内容： 123&gt; python26 test.pyFile "test.py", line 6SyntaxError: 'gbk' codec can't decode bytes in position 9-10: illegal multibyte sequence 使用 Python3.4 运行的结果如下，其实和上面错误一样，但是提示更直接了： 123&gt; python34 test.pyFile "test.py", line 1SyntaxError: encoding problem: gbk 结论：默认的 utf-8 编码中文，如果显式指定使用 gbk 读取，Python2 和 Python3 都没法做到。 6.脚本文件编码 utf-8 + 文件存储使用 utf-8脚本头部显式声明脚本文件编码格式为 utf-8，同时使用 utf-8 格式存储文件： 12345# -*- coding: utf-8 -*-import sysprint(sys.getdefaultencoding())print('中文') 使用 Python2.6 运行的结果如下，虽然读取正确了，但是 Python2 在 Windows 系统会默认使用 gbk 对中文进行解码，所以输出乱码： 123&gt; python26 test.pyascii涓枃 使用 Python3.4 运行的结果正常： 123&gt; python34 test.pyutf-8中文 结论：虽然文件存储编码和脚本文件编码都是 utf-8，但是 Windows 平台上，Python2 会按 gbk 解析中文，所以会输出乱码，可以在中文前面加 u 来解决u&#39;中文&#39;，或者显式使用 utf-8 进行一次 decode。 汇总下验证结果，可以得到如下的表格： 不同组合下 Python3 和 Python2 处理结果 Python3 Python2 默认脚本文件编码 + 文件存储使用 gbk SyntaxError，解析错误 SyntaxError，解析错误 脚本文件编码 gbk + 文件存储使用 gbk 正常输出中文 正常输出中文 脚本文件编码 utf-8 + 文件存储使用 gbk SyntaxError，解析错误 正常输出中文 默认脚本文件编码 + 文件存储 utf-8 正常输出中文 SyntaxError，解析错误 脚本文件编码 gbk + 文件存储使用 utf-8 SyntaxError，解析错误 SyntaxError，编码错误 脚本文件编码 utf-8 + 文件存储使用 utf-8 正常输出中文 中文输出乱码 总结下结论： 如果使用 Python2 请一定要使用 gbk 格式存储文件； 如果使用 Python2 尽可能使用 gbk 存储文件且显式声明脚本文件编码为 gbk，方便后续兼容 Python3； 如果使用 Python3 不管使用什么格式存储文件，但请一定保证显式声明脚本文件编码和存储格式一致； 不管是使用 Python2 还是 Python3，保持显式声明脚本文件编码的好习惯； 如果脚本有跨平台需求，推荐使用 Python3 + 脚本文件编码 utf-8 + utf-8 格式存储文件的组合；]]></content>
      <categories>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>python3编码</tag>
        <tag>中文</tag>
        <tag>utf-8</tag>
        <tag>汉字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python2 和 Python3 中默认编码的差异]]></title>
    <url>%2Fpython-defaultencode.html</url>
    <content type="text"><![CDATA[最近在使用 Python3.4 做一些脚本实现，发现对于编码的处理上和 Python2.6 有很大的不同，就此机会把相关知识做个梳理，方便需要的时候查阅。 先说下概念和差异： 脚本字符编码：就是解释器解释脚本文件时使用的编码格式，可以通过 # -\*- coding: utf-8 -\*- 显式指定解释器字符编码：解释器内部逻辑过程中对 str 类型进行处理时使用的编码格式Python2 中默认把脚步文件使用 ASCII 来处理(历史原因请 Google)Python2 中字符串除了 str 还有 Unicode，可以用 decode 和 encode 相互转换Python3 中默认把脚步文件使用 UTF-8 来处理(终于默认就支持中文了，赞)Python3 中文本字符和二进制分别使用 str 和 bytes 进行区分，也是使用 decode 和 encode 进行相互转换 关于默认脚本字符编码，因为对脚步文件处理的默认编码格式变了，所以很多针对内容的处理，都发生了变化，比如下面这个脚本。 1234import sysprint(sys.getdefaultencoding())print('中文') 使用 Python3.4 解释器运行结果如下： 123&gt; python34 test.pyutf-8中文 使用 Python2.6 解释器运行结果如下： 123&gt; python26 test.py File "test.py", line 4SyntaxError: Non-ASCII character '\xe4' in file test.py on line 4, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details 使用 Python2.6 报错就是因为第一条说的「Python2 中默认把脚步文件使用 ASCII 来处理」，但是脚步文件包含了中文，ascii 又没有覆盖中文，所以报错。如果我们把脚步稍作修改： 123456# -*- coding: utf-8 -*-import sysprint(sys.getdefaultencoding())print('中文') 增加了脚本字符编码的说明，再次使用 Python2.6 解释器运行结果为： 123&gt; python26 test.pyascii涓枃 因为明确指定了脚步文件编码格式为 utf-8，所以读取没问题，也就是说如果 Python2 脚本文件中包含了非 ASCII 字符时，一定要显式指定脚步文件编码格式，对于 Python3 因为默认的脚步文件编码格式就是 utf-8，所以没有这个问题(后面会有文章详细讨论这个问题)。 但是我们回头看下刚才的输出，结果显示为乱码。 乱码就涉及到另一个我们要说的不同点解释器字符编码，因为我们定义了 utf-8 格式读取脚步内容，但是因为 Python2.6 在 Windows 平台上，默认是使用 gbk 对字符进行 decode 输出，不信你看： 1234567891011121314&gt; python26ActivePython 2.6.6.15 (ActiveState Software Inc.) based onPython 2.6.6 (r266:84292, Aug 24 2010, 16:01:11) [MSC v.1500 32 bit (Intel)] onwin32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; s='中文'&gt;&gt;&gt; s'\xd6\xd0\xce\xc4'&gt;&gt;&gt; s.decode('gbk').encode('utf-8')'\xe4\xb8\xad\xe6\x96\x87'&gt;&gt;&gt; print('\xd6\xd0\xce\xc4')中文&gt;&gt;&gt; print('\xe4\xb8\xad\xe6\x96\x87')涓枃 完整描述下上面乱码出现的过程： 使用指定的脚本文件编码 utf-8 格式读取了「中文」，读取到的字符串内容为 ‘\xe4\xb8\xad\xe6\x96\x87’，然后输出时 Python2.6 的解释器使用默认解释器字符编码 gbk 格式对读取内容进行 encode 输出，但是之前 utf-8 是 3 个字节长度表示一个中文，而 gbk 是用 2 个字节长度来表示中文，所以之前的 2 个中文，在输出的时候就按照 3 个中文进行编码(encode)，当然就乱码了，仔细看那个乱码，就是 3 个字。 我们再用代码验证下上面说的内容： 12345678910111213# -*- coding: utf-8 -*-import sysprint(sys.getdefaultencoding())print('中文')print('\xe4\xb8\xad\xe6\x96\x87')print('\xe4\xb8\xad\xe6\x96\x87'.decode('gbk', 'ignore'))print('\xd6\xd0\xce\xc4'.decode('gbk').encode('utf-8'))print('中文'.decode('utf-8'))print('\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8'))print('\xd6\xd0\xce\xc4')print('\xd6\xd0\xce\xc4'.decode('gbk')) 看看输出结果： 12345678910&gt; python26 test.pyascii涓枃涓枃涓枃涓枃中文中文中文中文 很明显 gbk 格式解码的十六进制字符正常输出为中文了，显式使用 utf-8 对 utf-8 格式的十六进制字符进行 decode 也输出正常了。 同理，还可以看到另外 2 个现象： 把 py 文件用 utf-8 格式存储，并且包含「中文」字样时，如果使用 gbk 格式打开，也是看到「中文」显示的乱码和上面程序输出的一致；如果把 py 文件使用 gbk 格式存储，这时候 print(&#39;中文&#39;) 也显示正常了； 乱码的终极原因就是：对同一个字符串的 encode 和 decode 编码格式不一致。 上面说的这个问题，如果文件存储和脚本文件编码都使用 utf-8 时，使用 Python3.4 是没有问题的，因为 Python3 默认的解释器字符编码是 utf-8 了，默认就可以处理中文了。 总结下结论： Python2 脚步文件尽量使用 gbk 格式存储；同理 Python3 脚步文件尽量使用 utf-8 格式存储； Python2 脚步如果带有中文字符时，请务必在脚本开头声明能支持中文的脚本文件编码； Python2 中对同一个字符串的 encode 和 decode 编码格式请保持一致； 说明：本次所有测试脚本文件均保存为 utf-8 格式]]></content>
      <categories>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>decode</tag>
        <tag>encode</tag>
        <tag>编码</tag>
        <tag>python3默认编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由 Python2 和 Python3 中 socket.inet_aton() 实现不同引发的血案]]></title>
    <url>%2Fpython-socket-inet-aton.html</url>
    <content type="text"><![CDATA[这几天在做一个功能实现的时候，需要把别人用 Python2.6 写好的脚步转成 Python3.4 实现，大部分地方转化都没啥问题，但是在 socket.inet_aton() 转化的过程中出了点问题，花费我不少的精力去解决，先做个记录备忘，同时给后续需要的人做个提醒。 首先说一下，我在解决这个问题前期的思路有点问题，所以请关注最后的总结。 需求目的：把一个 ip 地址使用 socket.inet_aton() 转化后和一个字符串组合，然后算出 MD5。 下面是 Python2.6 的实现代码： 1234567891011#!python2# -*- coding: utf-8 -*-import socketimport hashlibif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' ip_md5 = hashlib.md5(socket.inet_aton(ip) + base_str).digest().encode('hex') print(ip_md5) 运行后的输出结果为： fc138bb4748a18f885cc321c2c6396e2 如果原封不动的使用 Python3.4 运行后，报错如下： 123456Traceback (most recent call last): File "socket34.py", line 25, in &lt;module&gt; test1() File "socket34.py", line 10, in test1 ip_md5 = hashlib.md5(socket.inet_aton(ip) + base_str).digest().encode('hex')TypeError: can't concat bytes to str 提示说的是，socket.inet_aton(ip) 的返回值是 bytes 类型，所以不能和 str 类型的 base_str 直接进行连接操作。 也就是说 Python2.6 和 python3.4 中对于 socket.inet_aton(ip) 的实现是有差异的，查官方文档吧。 python2.6文档说明： socket.inet_aton(ip_string)Convert an IPv4 address from dotted-quad string format (for example, ‘123.45.67.89’) to 32-bit packed binary format, as a bytes object four characters in length. python3.4 文档说明： socket.inet_aton(ip_string)Convert an IPv4 address from dotted-quad string format (for example, ‘123.45.67.89’) to 32-bit packed binary format, as a string four characters in length. 好吧，返回值类型不同，为了保证和原脚本逻辑一致，我就做个转化，把 bytes 主动转换为 str 类型再连接，修改后的代码如下： 123456789101112#!python3# -*- coding: utf-8 -*-import socketimport hashlibif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' str_md5 = socket.inet_aton(ip).decode('gbk') + base_str ip_md5 = hashlib.md5(str_md5).digest().encode('hex') print(ip_md5) 代码通过 decode 把 bytes 使用 gbk 的方式解码成 str，至于为什么用 gbk，是因为我对比了下，只有 gbk 编码方式解码后的输出才和 python2.6 中的 str 返回值结果一致。 行，赶紧运行一把试试看。。。还是报错了，这次的报错内容变了： 123456Traceback (most recent call last): File "socket34.py", line 34, in &lt;module&gt; test1() File "socket34.py", line 12, in test1 ip_md5 = hashlib.md5(str_md5).digest().encode('hex')TypeError: Unicode-objects must be encoded before hashing 看起来 hashlib.md5() 在 Python2.6 和 Python3.4 中的实现也有差异，继续看文档。 python2.6文档说明： You can now feed this object with arbitrary strings using the update() method. python3.4 文档说明： You can now feed this object with bytes-like objects (normally bytes) using the update() method. 依然是编码格式的问题，Python2.6 中参数传入的是 str，但是 Python3.4 中参数需要传入 bytes，那就继续转码吧。 再次转码后的代码如下： 123456789101112#!python3# -*- coding: utf-8 -*-import socketimport hashlibif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' str_md5 = socket.inet_aton(ip).decode('gbk') + base_str ip_md5 = hashlib.md5(str_md5.encode('gbk')).digest().encode('hex') print(ip_md5) 运行后再次报错： 123456Traceback (most recent call last): File "socket34.py", line 33, in &lt;module&gt; test1() File "socket34.py", line 11, in test1 ip_md5 = hashlib.md5(str_md5.encode('gbk')).digest().encode('hex')AttributeError: 'bytes' object has no attribute 'encode' 好吧，继续看文档。 python2.6文档说明： hash.digest()Return the digest of the strings passed to the update() method so far. This is a string of digest_size bytes which may contain non-ASCII characters, including null bytes. python3.4 文档说明： hash.digest()Return the digest of the data passed to the update() method so far. This is a bytes object of size digest_size which may contain bytes in the whole range from 0 to 255. 这次更严重，encode() 直接用不了，换方法吧，更新后的代码如下： 12345678910111213#!python3# -*- coding: utf-8 -*-import socketimport hashlibimport binasciiif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' str_md5 = socket.inet_aton(ip).decode('gbk') + base_str ip_md5 = binascii.hexlify(hashlib.md5(str_md5.encode('gbk')).digest()).decode() print(ip_md5) 运行后的输出结果： fc138bb4748a18f885cc321c2c6396e2 终于得到了最终结果，激动，不过再回头一看，如果知道这几个函数的使用方式的话，就不需要 decode() 然后又 encode()，比如稍微优化后的代码如下： 12345678910111213#!python3# -*- coding: utf-8 -*-import socketimport hashlibimport binasciiif __name__ == '__main__': ip = '192.168.1.12' base_str = 'testSTR' str_md5 = socket.inet_aton(ip) + base_str.encode() ip_md5 = binascii.hexlify(hashlib.md5(str_md5).digest()).decode() print(ip_md5) 总结： Python3 新增了 bytes 类型，对于 bytes 的转换逻辑要特别清楚，这地方涉及了编码类型，要特别关注； 在使用一些函数前，一定要搞清楚这个函数的具体实现，必须清楚的知道使用了这个函数是什么效果，而不仅仅是看到暂时的效果，或者经验主义的去调用(上面例子的最后一步，其实我一开始不是用的 binascii，而是用的现成的 md5 转换函数，导致 encode() 成了 utf-8 格式，而浪费了不少时间去定位)； 解决问题过程中，思路一定要清晰，不能靠猜，越猜越错； 先弄明白问题的根本原因，直接从根源上去解决，比一步步的就错解错，效果更好。]]></content>
      <categories>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>decode</tag>
        <tag>encode</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对权威的辩证认知]]></title>
    <url>%2F20170912-quanwei-renzhi.html</url>
    <content type="text"><![CDATA[之前很长一段时间，自己对「逻辑思维」是很迷恋的，不仅听公众号，还会听「得到」，我承认，好几锅的鸡汤我都干了。 迷恋的主要原因有下面两点： 老罗对自己输出的观点很自信，特别能感染人老罗对热点和人性的把握很到位，很多道理总是能说到心坎里 所以当老罗推崇「碎片化学习」时，我也感同身受，当时还写了一篇文字来说明自己对碎片化时间的利用。而在逐渐实践的过程中，却发现不能一概而论，特别是在看一些需要专心专注的内容时，碎片化学习简直就是灾难，因为刚进入状态，就被打断，根本没法继续，而已经消耗的时间也完全被浪费。 比如这几天在看「驱动力」，因为倡导的是第三驱动力，也就是内在驱动，为了更好的理解我需要把第一驱动、第二驱动完全理解，才能更好的对比和消化，但是因为只是利用早上上班前的一点时间，总是在梳理的时候因为上班时间到了而打断，每次继续之前，我又得重新花时间捋一下，造成时间的浪费。 再比如这几天在学习 Web 前端的基本实现原理，因为涉及 Html、CSS、JS、PHP等，需要系统的梳理，并理解各个角色的定位和作用，以及在实际展示时对应生效的机制，这些都是需要思考和梳理才能完成的，也尽可能在一段连续的时间内完成，不然效果要大打折扣。 当然，有些场景还是挺适合碎片化的，比如刷个朋友圈，比如回复下微信消息，比如瞄一眼热点新闻，再比如打个水、上个厕所等等，也就是不涉及深度思考的，其实还是有用的。 所以，我想说的是「对权威需要进行辩证的认知」。这里说「逻辑思维」为权威是因为它毕竟有900万的小伙伴。 还说一个逻辑思维的例子。 之前它推荐了一篇文章，开篇就说了一个很重要的观点「高自尊的人才靠谱」，还有一句「学校成绩好才说明对自己未来有期待」。当时对这种一刀切的观点甚是不明，简单粗暴固然好，但是直接抛出这么绝对的论调，还是挺让人意外的，特别还是受众这么大的权威输出的观点。 对于「高自尊」的说明，当时的例子是通过一个人本科院校的优劣，以及当时学习的成绩，甚至高考的成绩来判定，这些方面好的才算「高自尊」，其实也就是把上面的两句话合并下，「学校成绩好的人属于高自尊，高自尊的人对自己未来有期待，这样的人才靠谱」。 诚然，从某些角度说，这样当然没问题，毕竟学校成绩一直很好的话，那么这些人肯定有付出，所以肯定是满足「对自己有更高要求」的高自尊的标准，但是因为这些要求达不到而被归为「低自尊」确认让人难以理解。毕竟马爸爸也才毕业于杭州师范学院外语系，难道马爸爸属于低自尊行列？亦或者说，那些没上过多少学，却能够长期坚持清贫、不唯利益的特技传承者、技术专家们，都是低自尊行列？亦或者说那些努力学习，但是成绩就是达不到理想状态的人，只是因为自尊不够高？ 我不同意。 随着对「真理」追求的时间越长，越发现所有的事情离真理越来越远，反而「平衡」出现的次数越来越多，辩证的看待问题，才能保证客观，辩证的处理问题，才能保证公正。所以对于权威的输出，依然要保证有辩证的认知。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>权威</tag>
        <tag>认知</tag>
        <tag>得到</tag>
        <tag>逻辑思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教师节快乐]]></title>
    <url>%2F20170910-happy-jiaoshijie.html</url>
    <content type="text"><![CDATA[教师节了，这是个伟大的节日，我必须的纪念下，毕竟大宝已经开始她的学生生涯。 没有特别的目的，所以就想到哪说到哪，权当纪念了。 为了方便，就按时间线来说吧。 我关于老师的记忆其实还是挺早的，我上学那时候没有小中大班之分，直接就是学前班了，我们那时候的学前班都是才刚有的新鲜事物，所以并没有在学校开展，而是私人性质的。 我记忆中，我们学前班上学的地方是租借一个老乡的房子，传统的四合院，前排就当我们的教室了，当时的老师实在是记不清了，倒是房东挺有印象，后来听老爸说我经常到学校了还到房东家蹭饭吃，噢，原来我小时候这么胆大。 我的学习成绩一直并不突出，唯一印象深刻的奖状就是在学前班获得的，当时获奖的日记本就当作我们兄妹几个上学的账本了，至今留存。这里面要感谢学前班的老师，虽然我们能记住您，但是你给了我学生生涯的第一份肯定，而且自此之后我总是能碰见特别关照我这个学习成绩并不好的学生的老师，感谢！ 小学基本是在玩耍中度过，关于老师的最深记忆是小升初考试的带队老师。 说起来还挺有意思，我们村小升初考试是要到乡里面去参加的，当时我记得是学校租了一辆大巴车把我们拉去的，为什么记这么清是有原因的，且听我慢慢说叨。 考试经过什么样，考试结果什么样我已经记不清了，我只记得考试结束后中午吃饭，带队老师把我们都带到一个包子馆，要求我们每人买一份包子，好像是凑够了份数后，老师就可以免费吃了。 我当时应该是没同意，一起的还有其他几个同学，而老师的要挟是，不买就别坐车回去了，切，愣头小子是最不怕吓的，我们几个小子当即立断的决定走回去，走回去，走回去……，8公里呀，当时我们都是10岁冒头的年纪，而且从来没有单独出过这么远的门，现在想想都佩服当时的自己。 当时还有一个问题就是不知道路，但是一个同学给了一个绝妙的主意「我们顺着大马路走就行了，因为我们村就在马路边」，哈哈，事实是我们确实就这么干的，事实上我们也确实都走到家了。 说这个是主要不是为了贬损老师的，其实还应该感谢他，感谢他让我有机会在这么小的年纪就给自己拿主意，感谢他让我在这么小年纪就承担自己做事的后果，感谢他让我在这么小的年纪就明白「路在脚下」。 转眼就要初中毕业了，先大概齐说下初中过程吧，遇见了很厉害的物理老师，让我竟然有机会得到了一次物理模拟考试全校第一的成绩，备受鼓舞，遇到了很给力的英语老师，在自己方言口音这么严重的时候都没有放弃，信心大增，当然，其他老师也是一样的给力，就不一一列了，下面特别说明下毕业班的班主任老师。 小升初，我们是赶上了义务教育落实，所以直接升级了，但是初中毕业那可是拼真本事了，一般初中毕业都有两个方向，一个是中专(当时的中专还是很热门的，也不是所有人都能考上的)，偏技工的，学完应该就可以进入社会了，另一个是高中，但高中并不是这条路的终点，一个偏短期考虑，一个偏长期考虑。 介绍这么多是因为我们在考试前需要填报好志愿的，这个志愿就是上面说的高中、中专的学校，我和当时一起的一个饭友都报了咱们县高中，但是吃饭的时候听他说班主任建议他报中专，听到这个其实我是有一些后怕的，虽然我也进了学校的特训班但是我的成绩并不拔尖，如果我也被建议，那么十有八九就会同意了，虽然当时我给他的分析也是让他自己决定自己的未来。 很庆幸，班主任并没有找我说这事，我也就大大咧咧的继续往这个方向努力了，但是说，之前传说的是每年能升高中的机会我们学校只有前三名，现在想起来还是怕怕的。所以这里必须要感谢如此信任自己的老师，能让自己没有顾虑的往自己的目标去努力，没有丝毫犹豫，以至于最后被录取真的是远远超出预期了，虽然当时自己仅仅碰上了扩招而压线通过。 终于高中了，魔鬼般的高中竟然没让我有一丝魔鬼般的记忆，不知道是否是因为自己健忘，还是说这一切都是自己的选择而已，下面直接说重点。 首先，必须要重点感谢下高一的语文老师，在我多年作文跑题的经历后，竟然有一次的作文被当作范文在全班朗读，我清楚的记得当时的作文题目是「孔雀东南飞」。对学霸们来说，这可能是件小事，但是对于非自费入学的倒数第一名的学渣来说，我的自信心得到了极大的增强，而自己的「作家」梦想也从此不再中断，感谢，我想我这辈子都忘不了这件事了。 然后感谢下数学老师，就说一件事吧，高二某段时间，不知道什么原因坐到了最后一排，对于当时已经高度近视的我，只有在数学课时才会坚持使用双层镜片(戴个眼镜，然后再手举着个镜片叠一起看)认真听课、看板书、记笔记，当然，数学成绩也是我高考中最引以为傲的一门课了。 还有英语老师，并没有因为自己的资质差而放弃我，反而给我很多锻炼和学习的机会，至少我记得自己经常被喊起来回答问题。其实这个事并没有让我实际的英语成绩有很大的改善，高考成绩中英语依然是最差。这个事给我最大的帮助是让我从此都不怵英语了，我在之后直到至今，从来没有因为英语成绩不好而拒绝甚至反感英语，反而重返北京之后的第一个工作单位就是个外企。 这几个英语老师给予我的不仅仅是成绩提升那么简单的东西，而且也不仅仅是成绩那么简单的东西所能表达的，她们给我的是我内心中需要的那份肯定，所以我也尽我所能的给了她们肯定的答复。 碎碎念了这么多，肯定还漏掉了一些人，后面有机会再写吧，最后还是在这个特别的日子，感谢老师们的付出。为那些教学生做人、做人的道理以及方法、准则的老师点赞，为那些从内心深处去肯定每一位学生的价值和潜质的老师点赞，为那些授人以渔的老师点赞，为所有不辞辛苦、无私奉献的老师们点赞。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>教师节</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过度设计]]></title>
    <url>%2Fguodusheji.html</url>
    <content type="text"><![CDATA[今天来说点专业领域的话题，关于「过度设计」。 这里说的「过度设计」指的是人为的创造了过多非必要的需求实现。 打个最简单的比方，我们最常用的 office 套件，有多少人真正的使用过其中超过十分之一的功能实现？就算不使用，又有多少人知道 office 究竟可以实现哪些功能？在我知道的人里面，应该是很少人知道的。 可以因为 excel 写一本(好几本 + 不同版本)厚厚的使用秘籍，这也是没谁了，诚然，这也让一部分人依赖这个神奇的软件生存了下来。这不是贬损微软的意思哈，只是觉得这个例子很有说服力。 其实类似 office 这种过度设计的情况，在当前很多的软件实现中都很常见，经常会发现一个软件的很多功能都是需求人员意yin出来的结果。 比如今天用的麦当劳最新的触摸屏在线点餐系统，每次点击操作后，看着满屏推荐的美食，竟然不知道下一步如何操作，在我自以为是计算机专人人士的眼里，依然傻傻分不清，其中一个原因是，操作结果中推荐的内容太多，经常搞不清自己点了啥，或者是以为点错了啥。 推荐系统不是没有必要，如何做才是最重要的，比如传说中的 google 的推荐系统是首屈一指的，大家也比较信服和接受它的推荐。而麦当劳的推荐不是结果不恰当，而是显示的位置和方式不对，主次颠倒，体验大打折扣。 当然，这个系统作为刚需来说，大家还是会去适应它并使用它，但是想想，如果不是依附这个强需求，这样的产品设计谁会去用它。 再说一个正面的例子吧，软件安全界比较有名的几个工具：冰刃、pchunter 等，只是从 UI 上看，真的没有什么酷炫的实现，但是它们的功能强大到安全界的人几乎无人不知无人不晓，这不是酷炫的显示效果就能达到的，而是因为它的每个「丑陋」的按钮后面都是一个很实用的功能，所以能一直传承至今，并被奉为经典。 不过话说回来，用户需求其实是个伪命题，很多用户其实根本不清楚自己的需求，就像很多人不知道自己生活的目的和意义一样，但是有一样东西确实恒古不变的，那就是人性。 基于人性的需求的实现的例子可就多了，脑白金记得吧，它是满足人们需求的不，不是，它满足的是人性；各种sex网站，它是满足人们需求的不，这个其实也算是吧，但是说它是满足人性会更恰当；各种题型的游戏，这个更是完全从人性出发，可以算是最早的虚拟现实，让人性在游戏中得到另类的放大和发挥；然后人们熟悉的微信，也是必然的结果，虽然我一直认为他的各种设置入口简直不要太难找，但是他的主要功能是人们所需要和诉求的。所有这些，都在他们各自的领域大放异彩，因为他们各自在某种方面满足了人性的诉求。 再说回来之前的 office 套件，它是工具，基于人性出发的话，满足工作需要的工具就是好工具，所以虽然它功能繁复，但是各类人都可以从中找到适合自己的功能，从而满足了不同人群的使用需要，从这个意义上说，它是一个好工具。而如果从需求开发投入量说，应该还是有优化空间的。比如做个通用版，只需要把最常用功能进行提炼，一方面减少软件体积，一方面减少维护成本，而高级技能版，则可以为各类专业人士去设计了，但是目前的垄断地位可能没有让他们去改进优化的动力。 再说说麦当劳点餐系统，满足了人们要求快的需求，但是推荐逻辑是反人性的，同样因为没有更好的选择而被接受。 安全工具，满足了人们针对工具使用的需求和目的，同时也满足了人们物超所值的人性，被传播是当然的了。 最后借用伟大的腾讯对于产品设计的至高理念作为总结，需求设计的最高目标就是「不要让用户思考」。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>过度</tag>
        <tag>产品</tag>
        <tag>用户</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天时地利人和]]></title>
    <url>%2Ftiandiren.html</url>
    <content type="text"><![CDATA[《孟子·公孙丑下》曰：「天时不如地利，地利不如人和」。 《孙膑兵法·月战》曰：「天时、地利、人和，三者不得，虽胜有殃」。看，早在几千年前，我们的先知圣人就已经总结出来这么个真理，而且言简意赅，浅显易懂，但是直到今天，却仍然没有人太在意。 而当 1998 年马尔科姆·格拉德威尔写出了《异类》时，通过整本书的一半篇幅来描述「天时地利人和」的重要性，终于让人类觉醒了。 我们先看看这本书都说了些什么。 书中总共分了两大章节，第一章总结下来讲的就是「天时地利人和」，第二章节主要讲的是「社会继承对个人的影响」。 今天我们主要说说第一章的内容。第一章分别通过几个小节来分别举例说明了「天时地利人和」在现实生活中的体现。下面我们拿几个例子来说明。 先说说众所周知的比尔·盖茨吧，我们之前所了解的盖茨，都是从他退学开始，我们并没有去了解过他退学之前的事情。其实在他退学前，因为「天时」的原因，在他年龄刚好合适的时候出现了非打卡式计算机，而因为「地利」，他可以经常方便的到学校去使用最先进的计算机设备，而「人和」就是他在退学前，几乎完成了自己的 10000 小时积累。 因为有了这些凑巧的「天时地利人和」，才能看到目前我们眼中的比尔·盖茨。如果之前的过程中少了任何一个环节，历史将会大不一样，比如盖茨早出生或晚出生5到10年，时间窗口就可能过去，如果盖茨不是住在学校边上，或者不认识一个老爸赞助了学校计算机的同学，那么他不可能很快的越过自己 10000 小时积累的坎等等，所有这些都是一环扣一环。 另一个例子如犹太人鲍格妮特，他在合适的时间来到了美国，在合适的地方—一个可以让他的市场调查能力和他老婆的缝纫能力得到应用的地方，充分发挥了他和他老婆早已娴熟的技能，天时 + 地利 + 人和，让他可以在当时的场景下做的风生水起，最后的结果也当然是功成名就。 作者最后总结出来的关键点是：「出生的时间对」、「有人告诉你怎么做」、「自己知道去努力」，刚好对应的就是「天时地利人和」了。 这让我也想起自己入职目前所在公司的经历。 09 年因为个人原因打算从当时的单位离职，所以找同学帮忙内推了一下，10 年 1 月 28 号接到猎头电话时，在同学介绍的单位已经一面通过了，抱着试试看的心态，去了猎头介绍—也就是目前的单位来谈了谈，一面结束后很长时间没有结果通知，期间又继续到同学的单位二面，然后等体检通知，期间又来目前单位二面 + HR面，接着又是漫长的等待，还好这次换工作并没有特别着急，所以继续着同学单位的流程，而就在我体检结束的当天，3 月 8 号，目前单位的 offer 下来了，在经历一个多月漫长的时间后，最终还是接受了目前单位的 offer。 来看看，刚好在我准备离职时收到了猎头电话，之前和之后的都被我拒绝了，刚好因为这次换工作并不着急，有足够的时间等 offer，所以才能熬过漫长的一个多月反馈周期，刚好因为自己目前做的项目和新公司项目匹配度高，所以在面试过程中也起到了相当重要的作用。 天时、地利、人和，全了，事情也就水到渠成了。 在合适的时间，抓住合适的机会，并为此付出努力，那么离做成事情也就不远了，自勉。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>天时</tag>
        <tag>地利</tag>
        <tag>人和</tag>
        <tag>异类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 三大特性之多态]]></title>
    <url>%2Fjava-duotai.html</url>
    <content type="text"><![CDATA[大家都知道 Java 的三大特性是：封装、继承和多态。今天要介绍的是 Java 三大特性之多态：对象有多种表现形式，具体最终使用哪种形式由最后运行时情况决定。 使用多态必须要达到三个条件： 一个就是需要使用继承 一个就是涉及方法的重写 最后一个就是需要进行向上转型 前期绑定：也叫编译时绑定，主要表现类型是重载(overloading)，比如一个类中有一个或多个名称相同的方法，但是他们参数不同。 举个例子：1234567891011121314public class TestClass &#123; public static void main(String[] str) &#123; testMethod(10); testMethod("This is a string"); &#125; public static void testMethod(int iRet) &#123; System.out.println("int simple"); &#125; public static void testMethod(String sRet) &#123; System.out.println("string simple"); &#125;&#125; 输出结果： int simplestring simple 后期绑定：也叫运行时绑定，主要表现类型就是重写(overriding)，比如子类重写了父类的方法。 举个例子：123456789101112131415161718public class TestClass &#123; public static void main(String[] str) &#123; Father testMethod = new Son(); testMethod.getResult(); &#125;&#125;class Father &#123; public void getResult() &#123; System.out.println("I am a Father"); &#125;&#125;class Son extends Father &#123; public void getResult() &#123; System.out.println("I am the Son"); &#125;&#125; 输出结果为： I am the Son 只有普通的方法调用是可以多态的，直接访问的成员变量是不支持多态的。为了避免混淆，可以把成员变量设置为 private 属性。 举个例子：1234567891011121314151617181920212223public class TestClass &#123; public static void main(String[] str) &#123; Father testMethod = new Son(); System.out.println("testMethod.notMethod = " + testMethod.notMethod + ", testMethod.getNotMethod() = " + testMethod.getNotMethod()); &#125;&#125;class Father &#123; public int notMethod = 0; public int getNotMethod() &#123; return notMethod; &#125;&#125;class Son extends Father &#123; public int notMethod = 1; public int getNotMethod() &#123; return notMethod; &#125;&#125; 输出结果： testMethod.notMethod = 0, testMethod.getNotMethod() = 1 **从结果可以看出来，testMethod.notMethod 获取的是父类的变量的值，而不是子类的，但是 testMethod.getNotMethod() 则是获取子类的方法的返回值。 总结下就是，static 方法和 final 方法属于前期绑定，子类无法重写 final 方法，静态和非静态的成员变量都属于前期绑定。除了 static 方法和 final 方法（ private 属于 final 方法）之外的其他方法属于后期绑定，运行时能判断对象的类型进行绑定。** 来个例子：123456789101112131415161718public class TestClass &#123; public static void main(String[] str) &#123; Father testMethod = new Son(); testMethod.getResult(); &#125;&#125;class Father &#123; public static void getResult() &#123; System.out.println("I am a Father"); &#125;&#125;class Son extends Father &#123; public static void getResult() &#123; System.out.println("I am the Son"); &#125;&#125; 输出结果为： I am a Father 当继承和向上转型同时存在时，函数实现会遵循多态原则进行实际的调用，调用顺序为：this.method(class)、super.method(class)、this.method((super)class)、super.method((super)class)。 来个例子：1234567891011121314151617181920212223242526272829303132333435363738394041public class TestClass &#123; public static void main(String[] str) &#123; Father oneTest = new Father(); Son twoTest = new Son(); Father threeTest = new Son(); Son fourTest = new GrandDaughter(); //this.method(class) threeTest.method(oneTest); //super.method(class) threeTest.method(twoTest); //this.method((super)class) threeTest.method(threeTest); //super.method((super)class) threeTest.method(fourTest); &#125;&#125;class Father &#123; public void method(GrandDaughter grandDaughter) &#123; System.out.println("I am the Granddaughter in Father"); &#125; public void method(Son son) &#123; System.out.println("I am the son in Father"); &#125; public void method(Father father) &#123; System.out.println("I am the Father in father"); &#125;&#125;class Son extends Father &#123; public void method(Father father) &#123; System.out.println("I am the Father in Son"); &#125;&#125;class GrandDaughter extends Son &#123;&#125; 输出结果为： I am the Father in SonI am the son in FatherI am the Father in SonI am the son in Father 构造器方法默认都是 static 属性的，所以不支持多态。当时基类的构造器总是在子类的构造过程中被调用，而且按照继承层次逐级依次调用。 举个例子：1234567891011121314151617181920212223public class TestClass extends GouZaoQiThree&#123; public static void main(String[] str) &#123; new TestClass(); &#125;&#125;class GouZaoQiOne &#123; GouZaoQiOne() &#123; System.out.println("This is GouZaoQiOne"); &#125;&#125;class GouZaoQiTwo extends GouZaoQiOne&#123; GouZaoQiTwo() &#123; System.out.println("This is a GouZaoQiTwo"); &#125;&#125;class GouZaoQiThree extends GouZaoQiTwo&#123; GouZaoQiThree()&#123; System.out.println("This is GouZaoQiThree"); &#125;&#125; 输出结果： This is GouZaoQiOneThis is a GouZaoQiTwoThis is GouZaoQiThree 好了，作为 Java 的三大特性之一，多态在实际项目过程的使用会非常广泛，上述说明还需要在实践中多加锻炼才行。]]></content>
      <categories>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>封装</tag>
        <tag>java三大特性</tag>
        <tag>继承</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 三大特性之继承]]></title>
    <url>%2Fjava-jicheng.html</url>
    <content type="text"><![CDATA[前两天我们说了 Java 三大特性之封装，今天主要说说三大特性之继承。 下面我们会通过继承的特点和对应的例子来分别进行说明。 子类拥有父类非 private 的属性，方法。子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。子类可以用自己的方式实现父类的方法。 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestClass &#123; public static void main(String[] str) &#123; Son simple = new Son(); simple.method(); simple.printStr(); simple.method("simple"); &#125;&#125;class Father &#123; //父类的非private属性，子类也可以访问和使用 public String str = "Simple"; Father() &#123; System.out.println("This is the Father's " + str); &#125; //父类的非private方法，子类可以调用 public void method() &#123; System.out.println("This is the Father's method"); &#125; public void method(String strs) &#123; System.out.println("This is the Father's method with param"); &#125;&#125;class Son extends Father &#123; //子类可以拥有自己的属性 private String ownStr = "ownStr"; Son() &#123; super(); System.out.println("This is the Son's " + super.str); &#125; //子类可以拥有自己的方法 public void printStr() &#123; System.out.println("This is the " + "Son's method"); &#125; //子类可以重写父类的方法 public void method(String strs) &#123; System.out.println("This is the Son's method, " + "which is overriding from Father"); &#125;&#125; ​输出结果： This is the Father’s SimpleThis is the Son’s SimpleThis is the Father’s methodThis is the Son’s methodThis is the Son’s method, which is overriding from Father Java 的类继承是单继承，但是接口可以使用关键字 implements 实现多重继承(例子会在后面讲接口的时候详细说明)。子类会默认调用父类的无参数构造器，但是如果父类没有无参构造器，子类必须要显式的指定父类的构造器(有参数)，而且必须是在子类构造器第一行进行调用。 例子：12345678910111213141516171819202122232425262728293031public class TestClass &#123; public static void main(String[] str) &#123; new GouZaoQiTwo(); new GouZaoQiFour("simple"); &#125;&#125;class GouZaoQiOne &#123; GouZaoQiOne() &#123; System.out.println("This is GouZaoQiOne"); &#125;&#125;class GouZaoQiTwo extends GouZaoQiOne&#123; //子类会默认调用父类的无参数构造器&#125;class GouZaoQiThree &#123; GouZaoQiThree(String str) &#123; System.out.println("This is the gouzaoqi with param."); &#125;&#125;class GouZaoQiFour extends GouZaoQiThree&#123; GouZaoQiFour(String str)&#123; //如果父类没有无参构造器，子类必须要显式的指定父类的构造器(有参数)， //而且必须是在子类构造器第一行进行调用 super(str); System.out.println("This is GouZaoQiFour"); &#125;&#125; 输出结果： This is GouZaoQiOneThis is the gouzaoqi with param.This is GouZaoQiFour 继承后类型支持向上转型，比如 B 继承 A，那么B的实例也属于 A 类型。 例子： 12345678910111213141516171819public class TestClass &#123; public static void main(String[] str) &#123; GouZaoQiTwo gouZaoQiTwo = new GouZaoQiTwo(); //method方法的参数实际要求的类型是GouZaoQiOne， //但是因为GouZaoQiTwo是GouZaoQiOne的子类， //所以可以通过向上转型来满足参数类型的需要 gouZaoQiTwo.method(gouZaoQiTwo); &#125;&#125;class GouZaoQiOne &#123; public void method(GouZaoQiOne gouZaoQiOne) &#123; System.out.println("This is GouZaoQiOne"); &#125;&#125;class GouZaoQiTwo extends GouZaoQiOne&#123;&#125; 继承提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系），慎用继承。 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestClass &#123; public static void main(String[] str) &#123; ZiXingChe ziXingChe = new ZiXingChe("sylan215"); DianDongChe dianDongChe = new DianDongChe("sylan215-1"); ziXingChe.run(); ziXingChe.sleep(); ziXingChe.reboot(); dianDongChe.run(); dianDongChe.sleep(); dianDongChe.power(); &#125;&#125;class ZiXingChe &#123; private String name; ZiXingChe(String name) &#123; this.name = name; System.out.println("This is a " + name); &#125; public void run() &#123; System.out.println("I am a " + this.name + ", I can run"); &#125; public void sleep() &#123; System.out.println("I am a " + this.name + ", I need sleep"); &#125; public void reboot() &#123; System.out.println("I am a " + this.name + ", I need reboot"); &#125;&#125;class DianDongChe &#123; private String name; DianDongChe(String name) &#123; this.name = name; System.out.println("This is a " + name); &#125; public void run() &#123; System.out.println("I am a " + this.name + ", I can run"); &#125; public void sleep() &#123; System.out.println("I am a " + this.name + ", I need sleep"); &#125; public void power() &#123; System.out.println("I am a " + this.name + ", I need power"); &#125;&#125; 输出结果为： This is a sylan215This is a sylan215-1I am a sylan215, I can runI am a sylan215, I need sleepI am a sylan215, I need rebootI am a sylan215-1, I can runI am a sylan215-1, I need sleepI am a sylan215-1, I need power 看看合并后的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TestClass &#123; public static void main(String[] str) &#123; ZiXingChe ziXingChe = new ZiXingChe("sylan215"); DianDongChe dianDongChe = new DianDongChe("sylan215-1"); ziXingChe.run(); ziXingChe.sleep(); ziXingChe.reboot(); dianDongChe.run(); dianDongChe.sleep(); dianDongChe.power(); &#125;&#125;class CheZi &#123; private String name; CheZi(String name) &#123; this.name = name; System.out.println("This is a " + name); &#125; public void run() &#123; System.out.println("I am a " + this.name + ", I can run"); &#125; public void sleep() &#123; System.out.println("I am a " + this.name + ", I need sleep"); &#125;&#125;class ZiXingChe extends CheZi &#123; private String name; ZiXingChe(String name) &#123; super(name); this.name = name; &#125; public void reboot() &#123; System.out.println("I am a " + this.name + ", I need reboot"); &#125;&#125;class DianDongChe extends CheZi &#123; private String name; DianDongChe(String name) &#123; super(name); this.name = name; &#125; public void power() &#123; System.out.println("I am a " + this.name + ", I need power"); &#125;&#125; 输出结果为： This is a sylan215This is a sylan215-1I am a sylan215, I can runI am a sylan215, I need sleepI am a sylan215, I need rebootI am a sylan215-1, I can runI am a sylan215-1, I need sleepI am a sylan215-1, I need power 总结下继承的特点： 子类拥有父类非 private 的属性、方法； 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展； 子类可以用自己的方式实现父类的方法； Java 的类继承是单继承，但是接口可以使用关键字 implements 实现多重继承； 子类会默认调用父类的无参数构造器，但是如果没有默认(无参数)的父类构造器，子类必须要显式的指定父类的构造器(有参数)，而且必须是在子类构造器中做的第一件事； ​继承后类型支持向上转型，比如 B 继承 A，那么B的实例也属于 A 类型; 继承提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系），慎用继承；]]></content>
      <categories>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>封装</tag>
        <tag>java三大特性</tag>
        <tag>继承</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 三大特性之封装]]></title>
    <url>%2Fjava-fengzhuang.html</url>
    <content type="text"><![CDATA[学习Java，必须得了解Java的三大特性(封装、继承和多态)，今天就说说三大特性之一的封装。 封装就是把属性私有化，然后提供公共的方法来访问私有属性。 概念性的东西大家上网搜一下就行，下面我们分别举例说明封装的几个好处。 1.可以隐藏一些私有属性和一些实现过程。先看看封装前的代码： 123456789101112131415161718192021public class TestClass &#123; public static void main(String[] str) &#123; Flower newFlower = new Flower(); newFlower.name = "JuHua"; newFlower.chanDi = "China"; newFlower.time = 10; newFlower.xiShui = false; Flower twoFlower = new Flower(); twoFlower.name = "GuiHua"; twoFlower.chanDi = "China"; twoFlower.time = 30 twoFlower.xiShui = false; &#125;&#125;class Flower &#123; public String name;//花名 public int time;//最长花龄 public String chanDi;//产地 public boolean xiShui;//是否喜水&#125; 再看看封装后的代码： 1234567891011121314151617181920public class TestClass &#123; public static void main(String[] str) &#123; Flowers flowerSimple = new Flowers("JuHua", 10, "China", false); Flowers flowerSimple2 = new Flowers("GuiHua", 30, "Juke", false); &#125;&#125;class Flowers &#123; private String name;//花名 private int time;//最长花龄 private String chanDi;//产地 private boolean xiShui;//是否喜水 Flowers(String name, int time, String chanDi, boolean xiShui) &#123; this.name = name; this.time = time; this.chanDi = chanDi; this.xiShui = xiShui; &#125;&#125; 很明显，我们把类的属性给做了隐藏处理，然后使用公共的构造函数提供对外操作的入口，构造函数的实现过程也保持了对外的隐藏。 2.可以对赋值的属性进行一些代码处理，让代码逻辑更准确。 比如上面的例子中，封装前，对属性的初始化赋值是没有做任何兼容处理的，如果设置 newFlower.time = 100000; 程序不会报错，但是没有实际应用的意义了，所以也不能满足产品兼容性的要求，但是也没法进一步处理，而通过封装就可以很好的进行这种特殊处理。看代码： 1234567891011121314151617181920212223242526public class TestClass &#123; public static void main(String[] str) &#123; Flowers flowerSimple = new Flowers("JuHua", 100000, "China", false); &#125;&#125;class Flowers &#123; private String name;//花名 private int time;//最长花龄 private String chanDi;//产地 private boolean xiShui;//是否喜水 Flowers(String name, int time, String chanDi, boolean xiShui) &#123; this.name = name; //对传入的参数进行合理性校验，如果是封装前，肯定做不到这个效果 if (time &gt; 10000) &#123; System.out.println("The number is too big"); &#125; else &#123; this.time = time; &#125; this.chanDi = chanDi; this.xiShui = xiShui; &#125;&#125; 输出结果： The number is too big 3.可以在需要修改时只改变封装函数即可。 还拿第一个例子来说，如果是封装前，我们需要把 time 的类型改成 String，那么我们就需要在每个初始化的地方去修改初始化值为 String 类型，但是封装后则只需要做个简单处理即可，看代码： 1234567891011121314class Flowers &#123; private String name;//花名 private String time;//最长花龄，换成String类型了 private String chanDi;//产地 private boolean xiShui;//是否喜水 Flowers(String name, int time, String chanDi, boolean xiShui) &#123; this.name = name; //不修改任何实现，只是把传入的int通过String.valueof进行下类型转换即可 this.time = String.valueOf(time); this.chanDi = chanDi; this.xiShui = xiShui; &#125;&#125; 最后再总结下封装的好处： 1.可以隐藏一些私有属性和一些实现过程；2.可以对赋值的属性进行一些代码处理，让代码逻辑更准确；3.可以在需要修改时只改变封装函数即可。]]></content>
      <categories>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>封装</tag>
        <tag>java三大特性</tag>
        <tag>继承</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 实现文件递归遍历]]></title>
    <url>%2Fpython-wenjianbianli.html</url>
    <content type="text"><![CDATA[今天有个脚本需要遍历获取某指定文件夹下面的所有文件，我记得很早前也实现过文件遍历和目录遍历的功能，于是找来看一看，嘿，不看不知道，看了吓一跳，原来之前我竟然用了这么搓的实现。 先发出来看看： 123456789101112131415161718#遍历获取指定文件夹下面所有文件def getallfiles(dir): if os.path.isdir(dir): filelist = os.listdir(dir) for ret in filelist: filename = dir + "\\" + ret if os.path.isfile(filename): print filename#遍历获取所有子文件夹下面所有文件def getalldirfiles(dir, basedir): if os.path.isdir(dir): getallfiles(dir) dirlist = os.listdir(dir) for dirret in dirlist: fullname = dir + "\\" + dirret if os.path.isdir(fullname): getalldirfiles(fullname, basedir) 我是用了 2 个函数，并且每个函数都用了一次 listdir，只是一次用来过滤文件，一次用来过滤文件夹，如果只是从功能实现上看，一点问题没有，但是这…太不优雅了吧。 开始着手优化，方案一： 123456789101112#使用listdir循环遍历def getallfiles(dir): if not os.path.isdir(dir): print dir return dirlist = os.listdir(dir) for dirret in dirlist: fullname = dir + "\\" + dirret if os.path.isdir(fullname): getallfiles(fullname) else: print fullname 从上图可以看到，我把两个函数合并成了一个，只调用了一次 listdir，把文件和文件夹用 if~else~ 进行了分支处理，当然，自我调用的循环还是存在。 有木有更好的方式呢？网上一搜一大把，原来有一个现成的 os.walk() 函数可以用来处理文件(夹)的遍历，这样优化下就更简单了。 方案二： 123456789#使用listdir循环遍历def getallfilesofwalk(dir): if not os.path.isdir(dir): print dir return dirlist = os.walk(dir) for root, dirs, files in dirlist: for file in files: print os.path.join(root, file) 只是从代码实现上看，方案二是最优雅简洁的了，但是再翻看 os.walk() 实现的源码就会发现，其实它内部还是调用的 listdir 完成具体的功能实现，只是它对输出结果做了下额外的处理而已。 附上os.walk()的源码： 1234567891011121314151617181920212223242526272829303132from os.path import join, isdir, islink# We may not have read permission for top, in which case we can't# get a list of the files the directory contains. os.path.walk# always suppressed the exception then, rather than blow up for a# minor reason when (say) a thousand readable directories are still# left to visit. That logic is copied here.try: # Note that listdir and error are globals in this module due # to earlier import-*. names = listdir(top)except error, err: if onerror is not None: onerror(err) returndirs, nondirs = [], []for name in names: if isdir(join(top, name)): dirs.append(name) else: nondirs.append(name)if topdown: yield top, dirs, nondirsfor name in dirs: path = join(top, name) if followlinks or not islink(path): for x in walk(path, topdown, onerror, followlinks): yield xif not topdown: yield top, dirs, nondirs 至于 listdir 和 walk 在输出时的不同点，主要就是 listdir 默认是按照文件和文件夹存放的字母顺序进行输出，而 walk 则是先输出顶级文件夹，然后是顶级文件，再输出第二级文件夹，以及第二级文件，以此类推，具体大家可以把上面脚本拷贝后自行验证。]]></content>
      <categories>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>文件</tag>
        <tag>递归</tag>
        <tag>文件夹</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在前面]]></title>
    <url>%2Fxiezaiqianmian.html</url>
    <content type="text"><![CDATA[在毕业十年之后，我终于又开始重新审视自己的人生了，十年是一个不短的时间，甚至可以说毕业后的十年是人生中最宝贵的十年，那这十年里我都做了些什么呢？ 先是毫无目的的晃荡了 2 年，什么都不会做，就什么都做，从最基本的做起，从自己最不擅长的做起，逼自己做一些不喜欢的事，一直逼到最后自己实在没法忍受，也没法接受自己当时的状态了，终于选择遵从自己内心的选择。 毕业 2 年后，独自一人只身来到北京，开始了新的征程，对比之前的经历，对于新的选择就像找到了自己的归宿，感觉自己一直就应该做这些事，而这一做就是8年多，从懵懂无知到身经百战。 人都是很固执的，特别是当解决了马斯洛需求中最基本的几个需求层次后，那种固执尤其明显。 比如我从 16 年 3 月份开始写公众号了，原因仅仅是因为我高中时候的梦想是当一个「作家」。尽管之前我作文经常跑题，语文总是老大难，尽管工作总是很忙，总是抽不时间来写字，但是这些都没妨碍我的公众号断断续续更新了快一年时间了。 我能清晰记得自己对文字惦记的感觉，记得每写一篇文字后的成就感，记得公众号开通原创和赞赏时候的兴奋，哪怕大多数文字总是很浅显幼稚，哪怕每篇文字的阅读量都很低，但是这些是我喜欢做的，是我自发自愿做的，我仅仅是在试着实现自己的梦想，那种由心自发的感觉真是让人难以忘怀。 在逐渐往「作家」前进的道路上，自己的另一个固执症也发作了：技术。 自己特别喜欢那种专注于技术时的全神贯注的感觉，一心一意只是为了解决或实现某个问题持续不懈的努力，而这种努力是具象化的，努力的结果是直接能体现的，体现出来的就是那一个个饱含心血的作品。 生产作品这个过程中，切实感觉到的技术进步特别有成就感，同时产出的作品被别人使用和评价时，那种成就感更是油然而生，我喜欢并享受那种感觉。 其实十年前，我就坚持过技术的方向，只是因为各种原因没有坚持下去，可以说考虑的太多，或者说太瞻前顾后，或者其他能找出来的一堆原因，总之就是我在还没开始的时候就放弃了，而现在我决定要重新开始了，从十年前中断的地方重新开始了。 开始并不可怕，结束也不可怕，可怕的是失去在过程中坚持下去的动力，而这篇文章就作为这件事的开始，希望是对自己这个决定的见证，不管什么时候结束，只是为了看看自己能坚持多久，并尽可能的享受这个过程。 这里用「技术」这个词其实还是有点概括了，其实我主要想说的是编程技术，我计划捡起之前放弃过的编程，不管是作为副业还是主业，都一直努力的深究下去，而这个公众号就是记录自己努力的过程，我会把自己学习的成果尽可能的总结后产出。 每个人的一生中，能有多少个十年，我希望自己的下一个十年，依然是一个饱含激情、积极向上、勇往直前、努力奋进的十年。 不管结果如何，我都一直在努力。 So，Don’t be afraid， Just do it!]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>作家</tag>
        <tag>公众号</tag>
        <tag>编程</tag>
        <tag>十年</tag>
      </tags>
  </entry>
</search>
